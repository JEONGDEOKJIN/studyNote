

// $ npm i merkle


// 머클트리 최상단인 머클루트 값으로 데이터 무결성 검증
const merkle = require("merkle")

    /*
        [머클 트리]
            [의의] 
                - 이진 트리 중 하나 
                - 각 노드 = 데이터의 해시값
                - ⭐부모 노드 = '자식1의 해시값' + 자식 2의 해시값' 을 해시한 값⭐

            [특징]
                - ⭐'하나의 거래A가 8건의 세부 거래'⭐ 로 구성된다고 했을 때, A 거래가 변경되었는지 여부를 확인하려면? 
                    1) 8건의 세부 거래 각각을 확인할 수 있음 -> 8번 확인해야 함
                    2) 대신, 세부 거래를 머클 트리로 묶어서, 머클 루트로 확인함 -> 1번만 확인하면 됨.
                        -> so, ⭐⭐머클 루트 하나만 확인하면, 세부 거래가 변경되었는지 확인할 수 있음 ⭐⭐
                        -> 즉, '머클 루트' 하나로, '데이터 무결성 검증' 가능 
                        -> 머클 트리 구조를 블록체인에서 사용하고 있는 것 임. 

            [수업필기]
                merkle tree : 데이터의 암호화 구조가 트리 형태! 
                사진 자료 있음! 
                거래가 암호화 되고 -> 각 거래를 합쳐서 암호화 하고 -> 다시 합쳐서 암호화 
        
        [머클 루트]
            [의의]
                - 머클트리에서 최종적으로 남은 부모 노드값
    */



// 머클트리 들어갈 data
    const data = ["A" , "B" , "C" , "D" , "E"]

        /* [해석]
            머클 트리에 들어가서, '무결성 검증' 을 기다리는 데이터
        */

        /* 만약 머클 트리 자식 요소가 '홀수' 라면? 
            = ["A" , "B" , "C" , "D" , "E" , "E"];
            이렇게 E 를 한번 더 해시 해서(하나 더 만들어서), 사용한다. 
            '짝수' 로 짝을 맞춰서 사용한다. ⭐⭐
        */

// 머클트리 해시화 작업 시작
    const merkleTree = merkle("sha256").sync(data);
        /* 해석
            각 세부 data(최 하위에 있는 자식 노드) 가 들어와서 각각 hash 를 만들고 
            자식의 부모가 해당 값을 받아 또, hash 를 만들어내는 과정
        */

// 해시화 작업 결과 도출된 머클 루트 == 이것도 해시값임
    const Root = merkleTree.root();
    console.log(Root)   // AE4F3A195A3CBD6A3057C205DEF94520930F03F51F73C5A540D8FDAB05163FEF

    /*
        맞는지 확인하고 싶으면?
        A 해시화, B 해시화, 둘 다 더한다. -> AB 
        B 해시화, D 해시화, 둘 다 더 해! -> CD
        E 해시화, E 해시화, 둘 다 더 해! -> EE

        AB 해시화 + CD 해시화 -> ABCD
        EE 해시화 + EE 해시화 -> EEEE
        ABCD 해시와 + EEEE 해시화 -> 머클 루트 
    */
