<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <div id="root">

    </div>


</body>

<script>

    // 컴포넌트 기능 
        // 'ui 의 기본' 단위 
        // '재사용' 할 것 같은 애들을 만든다.
        // '조각' 만들고 -> '부모' 만들고 -> '부모의 부모' 만들고


    // 컴포넌트의 구성요소
        // 컴포넌트 안에는 '상태(state)⭐' 와 '속성⭐' 이 있음. 
        // '속성' 은 props 라는 것이 있음. 
    
    // CF. 'props' 와 'redux 저장소'
            // 1) react 는 데이터의 흐름이 '단방향성' 임. 
                // 즉, '부모에서 자식' 으로 값을 전달할 수 있고
                // '자식에서 부모에게' 값을 전달할 수 없음. 
            // 2. 만약, 내가 필요한 값이 내 형제 레벨에 있으면? -> 골치 아픔 -> 그래서 등장한게 '저장소!' 임. 
            // 사진 : https://i.imgur.com/WWWFXv1.png


    // Component 클래스의 흐름 
        // 1) target 과 state 를 속성 선언만 하고, 뭔가 할당하지는 않음. 
            // [알게된 점 👏]
                // 클래스는 '뼈대를 생성' 하는 역할 
                // '구체적인 값' 은 보통, 1) '인스턴스가 생성' 될 때 2) '객체가 생성된 이후' 에 생김. 

        // 2) 생성자 함수가 선언됨 
            // 즉, '해당 클래스가 객체를 만들어 낼 때' 필요한 '⭐초기화 작업⭐' 을 해준다. 
            // 그러면, 이 생성자 함수의 의도는 뭐지? 
                // a) 이 생성자 함수로 '객체'를 만들 때, target 이라는 매개변수를 받는다. 
                // b) 이 객체의 target 속성이 생기고, 해당 속성에는 매개변수가 값으로 들어온다. 
                // c) 그리고 이 객체 에는 ㄱ) setup 메소드 ㄴ) render 메소드가 들어간다.

        // 3) 아직 쓰여지지 않는 메소드 들이 있음. 
            // [궁금증😥]
                // 아직 constructor 에 쓰여지지 않아서, 초기화 함수에 사용되지 않는 메소드, 들은 어떤 기능을 하는거지? 
                // 즉, setEvent, template 메소드는, constructor 에 초기화 에 사용되지 않을거면, 왜 저 자리에 있는거지? 
                // 이건, 내가 '⭐class 의 기능⭐'을 오해하고 있어서, 발생하는 문제 일 수도 있어. 

                // [알게 된 것👏]
                    // 1) class 안에 있는 메소드 들은, constructor 에 의해, ⭐객체가 생성되고 난 후!⭐ 에도 호출될 수 있음. 
                    // 2) 그러면, ⭐'객체 인스턴스의 라이프사이클'⭐ 이라는 개념을 이해할 필요가 있어 
                        // a) class 는 객체를 탄생 시킨다. 
                        // b) 이렇게 만들어진 객체는 ⭐탄생하고 끝이 아니라, 어떤 추가적인 기능⭐을 하게 된다.
                        // c) 그래서, 반드시 만나게 되는 문제상황에 필요한 메소드를 추가하게 된다. 
                            // 마치, DB 에서 필요한 속성 및 table 을 추가하는 것 처럼.  
                
                // [궁금증😥]
                    // '객체 인스턴스 라이프 사이클' 이 뭐지? 
                    
                    // [알게된 것👏]
                        // '생성 - 사용 - 파괴' 의 3단계 가 있음.
                            // 1) 생성 : 메모리에 할당 
                            // 2) 사용 : 특정 작업 수행 
                            // 3) 파괴 : 메모리에서 제거 
                        // react에는 componentDidMount, componentDidUpdate, componentWillUnmount 등의 라이프사이클 메소드가 있음.
                        // 사진 자료 : https://i.imgur.com/7xga5hF.png
            
            // [궁금한 것] ⭐⭐⭐ 
                // 1)) 클래스가 만든 객체가 '탄생 이후 필요한 문제들을 만났을 때, 메소드를 꺼내서 쓴다면' 
                    // 만약, 인스턴스가 딱 문제를 마주했을 때, 필요한 메소드가 없으면, 
                    // 클래스를 다시 정의해줘야해? 아니면... 어떻게 해?          
                    // [알게된 것👏]
                        // 1) 인스턴스에서 필요한 메소드를 만들어서, '객체에 인스턴스를 추가 가능' 하다.  
                        // 2) 다만, 유지보수 및 가독성을 고려해서, '가능은 하지만! 지양' 할 것. 
                        // 3) 따라서, 애초에 class 정의를 잘 해야 함. 
                        // 4) 그래도, 필요한 메소드 추가가 필요하다면, a) 클래스를 재정의 b) 새로운 클래스를 만들어서 상속 받는다. 
                        // 5) 지금 예제가 ⭐'새로운 클래스를 만들어서 상속'⭐ 받는 것 임 

            // [알게된 것 👏]
                // 1) 클래스를 대할 때, '생성 - 유지 - 소멸' 의 관점에서 보면 
                    // 생성 = constructor, 
                    // 유지 = 다른 메소드들 
                    // 소멸 = 음... 뭔가 있겠지? 이렇게 보인다. 

                // 2) 처음 계획하는 시점에 미처 생각하지 못 한 기능은 '상속(extends)' 으로 만들 수 있다.


    // -------------- 👇👇👇  이러한 이해를 바탕으로 한번 예시를 이해해보자 👇👇👇 ----------------------  

    class Component { 

        // target 이라는 속성을 만들어놓음
        target; 
            // [궁금증😥]
                // 이렇게 덩그러니, 만들어놓으면, 어디 쓸모가 있나? 
                // 그냥, 객체의 속성만 만들어놓는게? 
                // [알게된 것👏]
                    // 1) 내가 '속성 : 값' 의 관계에 익숙해져서 그런 것 같아. 
                    // 2) 이 '덩그러니 놓여있는 순간' 이 필요한 이유는, 이렇게 덩그러니 놓여져 있어야, 원하는 곳에서 값을 가져와서 연결할 수 있다. 
                    // 3) 그리고, ⭐'속성 : 값' 이 한꺼번에 붙어있는걸⭐ 많이 봐왔는데, ⭐이렇게 차근차근 만나게 되는 과정도⭐ 익숙해져야 할 것 같다. 
                    // 4) 그리고, 이렇게 '덩그러니 있는 속성과 메소드 안에서 할당되는 방식' 에 '적응' 해야할 수 있다. 
                
        // state 라는 속성을 만들어놨음. 
        state;
            // [궁금증😥]
                // '덩그러니 놔두지 않으면, 인스턴스 객체의 속성으로 넣을 수 없나?'
                    // [알게된 것👏]
                        // 1) '덩그러니 놔두지 않아도!', 객체 안에 속성으로 만들어서 넣을 수 있음. 
                        // 2) class 에서 a) '덩그러니 놔두는 방법' b) 메소드 안에서 속성으로 넣은 방법, 이 아니어도, 
                        // 3) 인스턴스가 생성된 후, 얼마든지, 추가로, 객체 안에 속성을 만들 수 있음. 
                        // 4) 다만, '메소드와 마찬가지로!' 'class 안에 객체의 라이프 사이클에 필요한 메소드 및 속성이 모두!' 있는게, 파악하기 편함 
                        // 5) 그래서 'class 에 미리!' 있어야 하고 -> '덩그러니' 방식이 '메소드 안에 들어가 있는 방식' 보다 파악이 빠르기에, 덩그러니 방식이 더 효율적!

        // Component 클래스로 인스턴스를 만들 때, 들어갈 속성 및 메소드 디폴드 설정
        constructor (target) {

            // 클래스에서 요구하는 'target 속성' 을 '매개변수' 로 받아서, 할당(연결) 해줌
            this.target = target
                // [궁금한 점😥]
                    // target 이 어떤 기능을 하는거지❓
                    // target 은 일반적으로 'html 요소' 를 가리킨다. 
                
                // [코드 읽기]
                    // 1) 이걸 실행하면, 새롭게 만든 인스턴스의 target 속성에, 매개변수 target 이 할당됨

            this.setup();
                // [궁금증😥]
                    // 이렇게 하면, 인스턴스가 생성되는 시점의 객체에, setup 이라는 메소드가 정의 되는건가? 
                    // 아니면, 인스턴스가 생성되는 시점에 setup 도 실행되는 건가 ?
                    // [알게된 것👏]
                        // constructor 안에 this.setup() 을 하면, 
                            // 1) 지금 class 가 정의 되는 시점에 존재하는 setup 메소드가, 
                            // 2) 비로소, 그때 가서야, 실행이 된다. 
                        // new Component(target) 이 실행되면 ⭐⭐⭐⭐⭐
                            // 1) 생성자 함수이므로, 매개변수를 받을 수 있다는 점 ⭐⭐ 
                            // 2) 생성자 함수가 실행되면, target 이라는 매개변수를 반영한 객체, 가 만들어짐 
                            // 3) 이 객체의 속성 중 target 은 매개변수로 들어온 target 을 값으로 갖는다. 
                                // 그래서, ⭐이 객체(이 컴포넌트, 이 UI) 가 '렌더링되는 HTML 위치(요소)' 를 값으로 갖는다.⭐ 
                                // 결국, 이렇게, 이 객체의 target 속성에, 매개변수로 들어온 target 을 저장한다. | 할당한다. 메모리에 저장한다.
                            // 4) 이 인스턴스가 만들어지는 순간, setup 메소드가 실행된다. 
                                // 여기에서 this.setup 이렇게 붙어있어서, ⭐this 라는 객체에 대해서 setup 메소드가 실행⭐ 되어져야 하는 느낌이다.
                                // 그런데, 그건 아니고, this 라는 인스턴스가 객체로 생성되는 순간, ⭐실행된다는 의미로 읽을 수 있을 것 ⭐⭐
                                // [살짝 애매한 것📛] 
                                    // this 에 대해서 해당 메소드가 실행되는건지, this 객체가 탄생할 때 해당 메소드가 실행되는 걸로 읽어야 하는건지 
                                    // 우선, 'this 객체가 탄생할 때 해당 메소드가 실행' 되는 걸로 읽으면 되지 않을까. 
            
            this.render();
                // [궁금증😥]
                    // 그러면, 지금, this.render() 는 this 가 생성되는 시점에 그려주는 거야? 
                    // [알게된 것👏]
                        // 이렇게 하면, this 가 만들어지는 시점(인스턴스가 생성되는 시점)에, render 가 실행! 된다는 걸 의미한다.
                        // 이 특징을 알고 있어야, 나중에, 중복되어서 그리거나, 누적되거나, 안 그려지는걸 막을 수 있다. ⭐⭐⭐⭐⭐
                        // 즉, new Component (target) 실행 되는 순간 == 1) 컴포넌트가 그리고자 하는 타겟 HTML 요소를 가져오고, 2) render 메소드가 실행되는 순간 

                    // [알게된 것 👏]
                        // 그러면, 정의해놓은 메소드가 있어. 
                        // 그 메소드가 실행되는 시점이 1) 인스턴스가 생성되는 시점 2) 인스턴스가 생성되고 난 후(유지) 3) 인스턴스가 소멸될 때 로 나눌 수 있고 
                        // constructor 안에 넣으면, 인스턴스가 생성되는 시점에 실행되겠구나. 
                        // 마찬가지로, 그 시점 이후에 실행하고 싶으면, 인스턴스객체.setEvent 이렇게 실행하면 되는것임
                        // 그렇기 때문에, instance 가 생성되는 그 시점에 render 가 되는 것! ⭐⭐⭐ 

            console.log("나는 최초에 render 되었지🎏")
        }





    // 초기 설정 함수 
        setup() {
            // 컴포넌트를 초기설정한다. 
            // 렌더링 하기 전에 동작하는 함수
            console.log("component 초기 셋팅~")
        }


        template() {
            // 컴포넌트 HTML 템플릿을 반환해준다. 
            // 페이지에 그릴 HTML 
            return ""
        }
            // [코드 읽기]
                // 이 template() 이 실행되면, -> target HTML 요소의 innerHTML 로 들어간다. 

        
        render() {
            // '컴포넌트'를 'target 요소' 에 '렌더링'
            this.target.innerHTML = this.template();
                // [코드 읽기]
                    // 이 클래스의 constructor 함수에 따라 만들어진 객체의 target 속성은 == target 매개변수임 
                    // 그 target HTML 매개변수, 즉, 특정 HTML 요소에 대해, 그 안에, innerHTML 을 넣는다. 
                    // 뭘 넣어? 
                    // 이 class 의 template() 을 실행해서 넣는다. 

                // [궁금증😥]
                    // template() 이게 실행되는 시점은? 
                        // 1) render() 가 실행될 때 -> template() 도, 따라서, 실행된다. 
                        // 2) 그러면, render() 가 실행되는 건? 
                            // 이 경우엔, '초기 생성 시점' 에 실행된다. 
                    

            this.setEvent();
        }

        // 특정 HTML 요소에 대한, 이벤트 함수 호출 
            // [알게된 점👏]
                // 1. target 을 통해, 컴포넌트가 그려질 HTML 요소가 정해진다. 
                // 2. 그러면, ⭐해당 target 에 대해 할 수 있는, 고려할 수 있는 모든 것들⭐ 이 class 에 넣어진다. 
                // 3. 그 중 하나가, ⭐'해당 html 이 클릭 되었을 때'⭐ 와 같은 기능이다.
        setEvent() {    
            console.log("컴포넌트 이벤트 셋팅")
        }

        // 컴포넌트의 (데이터) 상태를 업데이트 하고 -> 업데이트 된 데이터로 '다시 렌더링(rerendering)'
        setState(_state) {
            
            this.state = {...this.state, ..._state}
                // 여기에서 this 는 앞으로 만들어질 인스턴스를 의미

            this.render();

            console.log("상태 바뀌고 렌더됨")
            
        }
    }

    // 가상 DOM 클래스 정의 
    // 렌더링 시킬 것 임 
        class VirtualDOM {

            constructor (component, target) {
                // 매개변수로 전달받은 컴포넌트 생성 후 , 타겟 요소 전달
                // 컴포넌트 클래스 생성자 함수의 매개변수로 타겟 전달
                this.Component = new component (target);
                    // [코드읽기🕵️‍♂️]
                        // VirtualDom 생성자 함수가 실행되면 
                            // 1) component 생성자 함수가 실행됨 -> 1) target HTML 요소가 반영되고 2) 객체가 생성되고 3) 생성 시점의 메소드(target, render, )가 실행됨 4) 유지 시점의 메소드는 그대로 안으로 들어가는 건가?❓❓❓
                            // 2) 그 결과가 VirtualDom 에 의해 생성된 객체의 Commponent 요소로 들어감
                    // [알게된 점👏]
                        // 1) 클래스 인스턴스 생성하면 -> 1) '클래스의 모든 메소드' 를 갖게 됨. 2) constructor 안에 있는 메소드 뿐 아니라 다른 것들도 갖고 있게 됨.
                        // 2) 이렇게 접근할 수 있는 이유는 
                            // a) 클래스의 모든 인스턴스는 같은 프로토타입(prototype)을 공유하기 때문 이고 
                            // b) 같은 프로토타입(prototype) 을 공유할 수 있는 이유는, js 가 '프로토타입 기반' 의 '객체 지향 패턴' 이기 때문에.
            }


            render() {
                this.Component.template()
            }
                // [코드읽기🕵️‍♂️]
                    // 유지 단계에서 사용될 메소드 
                    // render() 을 실행하면 -> 인스턴스의 Component 속성으로 가서 -> template() 를 실행시킨다.
                // [궁금증😥]
                    // component 클래스가 생성자 함수에 의해 불려지고, 그게 this.Componet 속성에 할당되면, 1) 생성 시점의 것들 뿐 아니라 2) component 클래스의 유지 시점에 쓰이는 메소드도 그 안으로 들어가나? 
                    // 왜냐면, template() 메소드가 굉장히 쌩둥맞게 등장했기 때문에. 
                    
        }
            // [궁금증😥]
                // 가상 DOM '실제 DOM 의 복사본을 만든다' 고 하는데, 이론은 알겠는데, 코드상 어떻게 구현이 되는건지 모르겠음.
                // '실제 DOM' 이라는 건, target 을 의미하나? 

            // [궁금증😥]
                // 생성자 함수의 매개변수로 들어오는 component 는 
                    // 'Component 클래스' 의 요소 중 '생성자 함수' 가 들어가는 건가? 

                // 생성자 함수가 전달되는 거면, 두 번째 요소로 나오는 target 은 component 생성자 함수가 필요로 하는 매개변수가 애초에 존재하므로 그걸 충족시키기 위해 나온거 겠네? 
                // 반대로, 해당 생성자 함수에서 필요로 하는 매개변수가 없으면, 나올 필요가 없는거고? 

                // 📛 내 생각이 맞는지 확인 필요. gpt 가 자신이 없는 거 같은데

            // [알게된 것✍]
                // virtualDom 의 기능은 
                    // 1) component 클래스의 생성자 함수를 실행해서 인스턴스를 만든다. 
                    // 2) 인스턴스 생성 시점에 실행되는 함수를 실행시킨다. (setup, render(template, setEvent))
                    // 3) 그리고 추후에 사용할 수 있는 render 메소드를 만든다. 

    // app class 컴포넌트를 상속받아서 만들어보기 
        class App extends Component {

            // 초기 셋팅 
            setup() {
                this.state = {items : ["아이템1" , "아이템2"]};
            }
                // [알게된 점👏]
                    // 기초 class 에서 추가 요소를 overwriting 할 수 있다.

            // html 을 리턴한다.
            template() {

                // app 컴포넌트의 HTML 을 생성해서 반환

                    // items 변수에, '배열통' 을 넣어줌
                    const { items } = this.state;

                    // map 함수로, 특정 연산을 거쳐, 문자열로 반환
                    return `
                        <ul> 
                            ${items.map((item) => `<li> ${item} </li>`)}
                        </ul>
                        <button> 추가 </button>
                    `
            }


            setEvent() {

                this.target.querySelector('button').addEventListener('click' , () => {

                    const {items} = this.state;
                    this.setState({items : [...items, `아이템 ${items.length +1}`]})
                })
                this.target.query

            }


        }

        // [궁금증😥]
            // 왜 초기에 Component 에서 전부 다 정의하지 않고, 1) component 에서는 뼈대 2) apps 에서는 그 하위 요소를 구현하는거지? 
            // 무엇을 위해? 



        const root = new VirtualDOM ( App , document.querySelector('#root') )
        // [궁금증😥]
            // App 자리는 component 자리 아닌가? 
            // component 자리인데, 그 component 의 상속을 받는 App 이 오는 것도 무방해 괜찮아? 




        root.render();


</script>


</html>