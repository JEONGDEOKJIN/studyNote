<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>

<script>

    /*  [문제 상황]
        만들고 싶은 것
            1) 00 함수를 실행하면 -> 1씩 증가 하게 하기 ex) 좋아요 클릭한 사람들 세고 싶음 
            2) 이 숫자가 중요하니까, 함부로 변경 못 하게 하고 싶어
        
        중첩함수 말고, 더 간단하게 할 수는 없나? 
    */
    
    // 중첩 함수 말고 간단하게 구현한 버전 
        let likeCount = 0; 

        function increamentLike(){
            likeCount += 1;     
                // [해석] 새롭게 변수를 선언하는게 아니라, 전역 변수인 likeCount 에 재할당 한다. 
                // 즉, 실행 단계에서 - likeCount 식별자 검색 시, 해당 스코프에 존재하지 않으므로 -> 상위 스코프로 이동 -> 식별자 선택 
                    // 해당 식별자를 참조 및 재할당 -> 값 update 
            console.log(likeCount)
        }

        increamentLike()   // 1
        increamentLike()   // 2 

    /* 이 방식의 문제점 
        1. 전역 변수에 초점을 둔 관점 
            - likeCount 변수가 '전역 변수' 이기 때문에, '의도치 않은 재할당' 이 될 수 있음. (오염 가능성)
            - 신뢰도 있는 숫자 여야 하는데, 변경될 위험성이 있음 
    
        2. '순수 함수의 기능' 에 초점을 둔 관점 
            - 순수 함수는 
                1) 동일한 입력에 대해, 동일한 출력을 반환 하고 (입력 관점에서, 외부 상태에 의존하면 안 된다는 점)
                2) 출력시, 외부 상태를 변경하지 않아야 함 (만약 외부 상태를 변경하게 되면, 위에 처럼, 의도치 않게, 데이터를 오염 시킬 수 있어)
                3) 왜 그래야 해? 
                    a) 그래야, '함수의 예측 가능성' 과 
                    b) '함수의 재사용성' 을 높일 수 있어. 
            - 따라서, '함수' 를 쓸 때, '순수 함수' 의 기준에서 벗어나게 되면, 문제들이 발생.  
            
            - 이러한 관점에서 위 코드를 볼 때, likeCount 변수는, 외부의 상태값에 '의존' 하고 있다.


        3. 그러면, '순수 함수' 가 아닌 코드는? 
            a) input 의 관점에서, 외부 상태에 의존해서는 안 됨. ex) 전역 변수의 값을, 함수 스코프에서 변경하는 경우 
                    let externalValue = 5;  
                    function multiplyByExternalValue(num) {
                        return num * externalValue;
                    }
                    console.log(multiplyByExternalValue(2)); // externalValue가 5이므로 결과는 10
                    externalValue = 10;
                    console.log(multiplyByExternalValue(2)); // externalValue가 10으로 변경되어 결과는 20

                
            b) output 의 관점에서, 외부 상태를 변경해서는 안 됨. ex) 사이드 이펙트 발생
                    let myArray = [1, 2, 3];

                    function addElementToArray(element) {
                        myArray.push(element);
                    }

                    addElementToArray(4);
                    console.log(myArray); // [1, 2, 3, 4] - myArray가 변경됨

                    addElementToArray(5);
                    console.log(myArray); // [1, 2, 3, 4, 5] - myArray가 다시 변경됨
            
            c) I/O 작업 예시    
                    - I/O 작업 : ⭐ 외부 시스템과의 상호작용! -> 항상 호출될 때 마다, 다른 결과가 반환되는 것이 불가피함 ⭐⭐⭐
                    - I/O 작업 예시 : 네트워크 요청에 따른 서버의 반환값(요청 유형마다 다른 값이 반환), 파일 읽기/쓰기, DB 쿼리 등 
                    
                    function getCurrentDate() {
                        return new Date(); // 현재 날짜와 시간을 반환
                    }

                    console.log(getCurrentDate());   // 매번, 각기 다른 현재 시간이 출력됨! 


        4. 시사점 
            1) 순수함수가 아닌 함수도 필요함. 모든 함수를 순수함수로 만들 필요는 없음. 
            2) 순수함수가 필요하다면, '입력에서 외부 상태값에 의존하지 않고' , '출력시, 외부 상태값을 변경하지 말아야 함'
            3) 순수함수가 필요한 경우들은 ⭐⭐⭐⭐⭐⭐⭐
                a) 함수형 프로그래밍 
                b) 데이터 변환 및 처리 : 새로운 배열을 반환함. 원본 배열 변경하지 않음.  
                    function squareNumbers(numbers) {
                        return numbers.map(number => number * number);
                    }

                    const originalNumbers = [1, 2, 3, 4];
                    const squaredNumbers = squareNumbers(originalNumbers);

                    console.log(originalNumbers); // [1, 2, 3, 4] - 원본 배열은 변경되지 않음
                    console.log(squaredNumbers);  // [1, 4, 9, 16] - 새로운 배열 반환

                c) 재사용 가능한 로직 : 동일한 입력에 대해, 같은 값을 반환
                function capitalizeString(str) {
                    return str.charAt(0).toUpperCase() + str.slice(1);
                }

                console.log(capitalizeString("hello")); // "Hello"
                console.log(capitalizeString("world")); // "World"

                d) 리액트 컴포넌트 및 리덕스 리듀서 (📛📛📛 이건 좀 더 이해 필요)                
                function Greeting({ name }) {
                    return <h1>Hello, {name}</h1>;
                }

                // 사용 예시: <Greeting name="Alice" />


        5. 그러면, 이 방식의 대안은? 
            - 클로저로 작성해보기 
    */


/*  - 클로저로 구현 해보기 
        1. 구현 세부 기능
            - 1) 이전 정보를 기억하고 있다가, 2) 누적해서, 업데이트 하기
        2. 구현 방안
            2.1 전역 변수 사용 
                1) '데이터를 기억하는 변수' 가 원치 않은 작동으로 '오영' 될 수 있음. 
                2) 증가 함수의 관점에서, 외부 상태 변수를 사용하기에, 순수함수의 기능을 상실 -> 향후, 함수 재사용성이 떨어질 수 있음. 
            
            2.2 클로저
                - 이전 정보를 기억하는 방식
                    : 함수의 중첩 관계에서, 내부 함수가 참조하고 있는 상위 스코프의 렉시컬 환경을 사용
                    : '기억 한다' = 메모리를 사용한다 = 실행 컨텍스트 안에 있는 렉시컬 환경을 사용한다. 
*/

        function outerIncrementFn(){

            let counter = 0;

            return function innerIncrementFn(){
                counter += 1;
                console.log("증가된 counter" , counter);
            }

        }

        const innerIncrementFn = outerIncrementFn()

        innerIncrementFn() // 1
        innerIncrementFn() // 2
        innerIncrementFn() // 3
        innerIncrementFn() // 4
        innerIncrementFn() // 5

        /* 
            1. 전역 평가 
                G.L.E = { 
                    레코드 : {
                        outerIncrementFn : {함수 객체}, 
                        innerIncrementFn : 초기값 없음
                    } 
                    this
                    외부
                }

            2. innerIncrementFn = outerIncrementFn() 실행 
                2.1  outerIncrementFn() 실행 
                    2.1.1 평가 
                        o.l.e = { 
                            레코드 = { 
                                counter : 초기값 없음
                            }
                        }
                    2.1.2 실행 -> innerIncrementFn 평가
                        I.L.E = { 
                            record : 등록된 식별자 없음
                            this : 
                            외부 참조 : 상위 스코프
                        }
                    2.1.3 return 실행 -> innerIncrementFn 함수 반환 
                        ⭐⭐⭐ (이 부분에서 나는 innerIncrementFn 함수가 실행된다고 생각함. 그런데, 평가만 이루어지고, return 이 실행되는거 였음) 

                2.2 innerIncrementFn = outerIncrementFn() 실행 
                        -> innerIncrementFn 식별자에 return 된 함수 객체 할당 
                            - 📛 '함수 객체가 들어간걸까? 아니면, 함수 안에 있는 변수 까지?' 를 궁금해 했었는데, 함수 객체값 전체가 들어간 것 임)
                                function innerIncrementFn(){
                                    counter += 1;
                                    console.log("증가된 counter" , counter);
                                } 
                            - 그리고, return 된 순간! outerIncrementFn 실행 컨텍스트는 콜 스택에서 pop 됨 -> 다만, innerIncrementFn 에서 해당 렉시컬 환경을 참조하고 있으므로, outerIncrementFn 은 유지! 
            
            3. innerIncrementFn() 실행 
                3.1 innerIncrementFn 식별자의 메모리에 바인딩된 함수 본체 innerIncrementFn 이 실행됨
                3.2 innerIncrementFn 본체 안에서 counter 식별자 검색 -> 없음 -> 상위 스코프 -> outerIncrementFn 렉시컬 환경에 있음 -> 해당 부분의 값 0 가져옴 -> +1 함
                            -> 그 결과, outerIncrementFn 렉시컬 환경에 있는 환경 레코드 값이 변경됨
                3.3 innerIncrementFn 본체 안에서 console 식별자 검색 -> 체인 따라서 전역 객체 까지 감 -> counter 식별자 검색 -> 스코프 체인 따라서, 'outerIncrementFn 렉시컬 환경' 에서 counter 참조 -> 위에서 1 증가했으므로 1 이 찍힘 


            4. 다시, innerIncrementFn() 실행
                4.1 innerIncrementFn 식별자에 바인딩 되어 있는건, 'innerIncrementFn 본체' -> 'innerIncrementFn 본체' 를 실행 
                4.2 새로운 선언문이 없으므로, 평가할 사항은 없음 
                4.3 counter 식별자 검색 시도 -> innerIncrementFn 스코프 안에 없음 -> 상위 스코프로 이동,  outerIncrementFn 스코프에서, 이미 counter 식별자를 기억하고 있었음 ⭐⭐⭐⭐⭐ 
                            -> 따라서, 기존 1에서 +1 하여 -> 2가 됨 
        
        */



</script>

</html>