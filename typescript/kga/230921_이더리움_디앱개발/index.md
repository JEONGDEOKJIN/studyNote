

# 이더리움 개발 


## 이더리움으로 개발하기 위해 필요한 개념 
    - block : 트랜잭션 및 데이터를 모아서 하나의 블록에 저장한다.
    - account
        - account 가 2종류 있음 
        - EOA 와 CA 가 있음 
        - EOA 는 개인키가 있는 계정. 지갑. 토이 비트코인에서 했던 ⭐'개인키'⭐가 존재하는 account
            - account 는 이더리움이 생기고 나서, 유명해지기 시작
            - 개인키가 존재하는 지갑
        - CA 
            - '컨트랙트 코드'에 의해서 제어되는 스마트 컨트랙트 어드레스 어카운트
            - 컨트랙트 코드가 있고, 코드에 의해 제어되는 'address(=account)'
            - privateKey 없음. 
            - 두 계정 모두 잔액을 가지고 있음. 
            - 4가지 전부 다 가지고 있음. 


    - Message 와 transaction 
        - transaction 은 메시지의 수신자가 이더를 보낼 때, 서명을 해서 보내면, 트랜잭션
        - 서명이 없으면, Message! 
        - 무조건 EOA 계정에서 생성됨. 
        - 'CA 에서는 보내지 못 함'⭐⭐. 
            - EOA 가 보내고 -> 다시 CA 가 보낸다.

    - ETH : 이더리움 네트워크에서 사용하는 암호화폐의 기본 단위
        - 원래, ⭐트랜잭션 발생⭐할 때 사용하는 자원인데, 현재는 코인으로 사용되는 경향


# 이더리움 개발할 때 사용하는 툴 

1. geth
    - go 언어로 작성이 되어 있는 이더리움 클라이언트
    - 스마트 컨트랙트 배포와 실행까지 할 수 있음. 
    - chain ID(블록체인의 고유 식별자) 를 확인해서, 테스트넷 인지, 뭔지 까지도 확인이 가능. 
    - chainID 를 통해 '메인넷' 인지 '테스트넷' 인지 구분할 수 있음. 

    - 사용 이유는 테스트 환경 구축 
    - 현재, 
        - 이더리움이 POS 로 전환되면서, geth 로는 docker 로 받아도, 오류가 있음. 
        - ⭐이전 버전을 받아서 할 수 있지만, 현재는 안 됨. 

2. Ganache
    - 로컬 개발 환경 및 ⭐테스트 환경을 제공해준다. (이더리움 네트워크를 로컬 환경으로 제공해줌)
    - 배포하기 전 이녀석으로 테스트 진행

3. '파운드리'
    - 작년
    - 솔리디티로 TDD 할 수 있음. 
    - 솔리디티로 ⭐테스트 코드 할 수 있음. 

4. 메타마스크
    - 브라우저에서 사용하는 확장 프로그램
    - 이더리움 스마트 컨트랙트와 상호작용하기 위해 사용됨
    - 개인키를 직접 전달하지 않아도, 사용할 수 있게! 
    - 브라우저의 확장 프로그램으로, 웹 어플리케이션에서, 이더리움 스마트 컨트랙트와 상호작용 할 수 있도록, 도와준다. 
    - 개인키 관리, 트랜잭션을 발생하면, 서명을 트랜잭션에 전달, 할 수 있다. 
    - ⭐개인키 -> 보안키를 만들어서 안전하게 보관 

5. Truffle, Hardhat(굳이 사용할 필요는 없음. 왜냐면, 다른 애들이 더 잘만듦)
    - 스마트 컨트랙트 개발
    - 테스트 배포를 쉽게 할 수 있도록 도와주는 프레임워크
        - 프레임워크 = 폴더 구성이 있다는 말 


# Ganache
    - 로컬 개발 테스트 (이더리움 네트워크)
    - 테스트 네트워크 보다, 가나쉬에 올려서, 테스트, 할 수 있게 하는, 라이브러리
    
    - RPC 개념이 왜 필요하지? 👇👇 



# RPC (Remote Procedure Call)
    - 프로시저(procedure) 란?
        - '절차' 를 의미 
        - '특정 작업을 수행' 하기 위해 정의된, 코드 블록 

    - 프로시저 VS 함수 의 특징 
        - 함수는 
            - '입력' 에 따른 '출력' 이 '무조건' 있어야 함. 왜냐면, 출력 발생을 '목적' 으로 함.       EX) undefined 같이!! | 
            - 클라이언트 쪽에서 처리를 함(계산, 연산, 작업, 수치가 필요할 경우 사용)  

        - 프로시저는 
            - '반환값'이 있을 수도 있고, 없을 수도 있다. ⭐⭐
            - 왜냐면, '출력값에 집중 보다' , `명령의 단위가 수행하는 ⭐절차` 가 중요 
            
            - '서버 단' 에서 주로 처리 시킴.  
            - 즉, '명령 단위' 에 따라, '수행하는 절차' 가 중요

    
    - PRC 란? 
        - 별도의 원격 제어를 위한 코딩을 하지 않고, '다른 주소 공간'에 '프로시저'를 '실행'할 수 있게 하는 프로세스 간 통신 
        
        - RPC = 원격 프로시저 호출의 약자 

 
## RPC 통신을 언제 사용하나? 
    - 일반적으로, 코드를 작성하고, 프로그램을 실행시키면, 함수는 자신의 메모리 공간에서 기능을 한다. 

    - RPC 의 경우, 내 컴퓨터에 있는 함수(기능) 실행이 아니라, 다른 주소에 있는 내용을 실행시키고 싶어서 사용한다. ⭐⭐⭐⭐⭐⭐ 

    - RPC 는 자신과 ⭐다른 주소⭐에 있는 메모리 공간에서 동작하는 프로세스의 함수를 실행할 수 있게 해준다. 

    - 반환값이 아니라, 그 명령 수행 하는게 중요할 경우! 


## RPC 사용의 장점 
    - 이미 만들어져 있는 함수를 사용 
    - 따라서, 기능은 원격으로 거기에서 실행 시키게 만들고, 비즈니스 로직을 개발하는데, 집중을 할 수 있음. ⭐⭐⭐ 

    - ⭐ RPC 통신을 통해 > 이더리움 네트워크에 요청을 보내는 것 
        > 이더리움 원격 으로 실행하고, 반환값이 있을 수도 있고 


## ganache 설치 및 열기
```
npm i -g ganache-cli
npx ganache-cli
```


## RPC를 이용해서 함수 호출 
요청을 보낼 때, AXIOS 를 썼었음 
지금은 간단히 보낼 것 임. 
postman 
git bash 로 json 객체를 보내게 됨

``` JSON 
{
    "jsonrpc" : "2.0",   // json-RPC 버전이 2버전임! 
    "method" : "web3_clientVersion",    // 실행시킬 메서드 이름
    "params" : [],      // 메서드에 전달할 인자값(매개변수)
}
```

``` bash
# 위의 json 을 cli 환경에서 요청 보내기
# 새로운 bash 창을 열고, 해야 함

curl -X POST -d '{ "jsonrpc" : "2.0" , "method" : "web3_clientVersion"  , "params" : []}' http://127.0.0.1:8545 
    # -X POST : 요청 타입 . | get 인지 post 인지 | post 타입이라는 말
    # -d `{ "jsonrpc" : "2.0" , "method" : "web3_clientVersion"  , : 전달하는 데이터의 내용 
    # http://127.0.0.1:8545  : 요청하는 주소 | 로컬환경이 열려있는 가나쉬 주소를 보냄 

    # 실행결과 
        # ganache 로 이더리움 네트워크 테스트 환경에서, web3_clientVersion 메소드를 실행시키는데
        # PRC 통신으로 요청을 보내서 
        # 네트워크의 web3_clientVersion 메서드를 실행시키고 
        # 반환받은 메시지는 {"jsonrpc":"2.0","result":"EthereumJS TestRPC/v2.13.2/etumJS TestRPC/v2.13.2/ethereum-js"}  /kga/studynote/typescri 
        # ❓❓❓❓❓❓❓ 내가 지금 제대로 반환 받았나? 
```

### 지갑에 있는 잔액 확인 

``` BASH
# eth_getBalance 함수를 RPC 통신으로 요청을 해서 > 계정의 잔액 확인

    curl -X POST -d '{"jsonrpc" : "2.0", "method" : "eth_getBalance", "params" : ["0x9506ce8f5e03336c80A112c88FA7cc38671a4b19"]}' http://127.0.0.1:8545
    # [결과 해석]
        # {"jsonrpc":"2.0","result":"0x56bc75e2d63100000"}  
        # 0x56bc75e2d63100000 : 0x 16진수 | 이게 잔액임 | 단위는 웨이(Wei)
    
    # [파라미터 해석]
        # params : 조회할 계정의 주소! 
        # 지값에 있는 잔액 확인

    # [메소드]
        # 사용하는 메소드 : eth.getBalance(매개변수) 
        # web3 라이브러리를 사용하면, eth.getBalance() 메소드에 . 으로 접근함. 
        # 다만, RPC 로 호출하면, _ 로 접근 
```

- 단위 
    ```
    - WEB3 에서는 getBalance 호출을 하면 -> 10진수로 변환해서 변환값을 주고 
    - wei 는 단위를 만들어 둔 것 이고, 이더 단위로 변경을 하려면 
    - wei 단위를 -> eth 로 변경 

    - 1eth === 100 x 10e18 wei 임 
    - wei = 10**18
        - 이더의 단위로 변경하면 이렇게 됨. 
    ```


## 이더리움 트랜잭션을 발생시킬 때의 가스비 

- 주유소 예시
    - 리터당 가격 : 2000원
    - 총 넣고 싶은 가스량 : 20리터 
    - 발생한 총 주유비 : 20리터 x 2000원 = 40,000원

    - 가스비당 가격 : 2000원 
    - 총 쓰고 싶은 가스 : 20? 
    - 총 발생한 가스비 : 2000원 x 20 = 40.000원

    CF. 리터가 gasPrice(리터당 가격) : gasPrice 2000원 
        - gas : 가스의 리터당으로,  계산 값의 총 가스량. 20리터. | 우리가 발생시킬 수 있는 총 제한량. 

    - 트랜잭션 발생시 총 수수료는 gas x gasPrice

    - 가스비 : byte 당 5gas



## 트랜잭션 보내보기 

```
받는 사람, 보내는 사람, 잔액 
```

## sendTransaction 

``` bash

# 1st cli 에서 npx ganache-cli 를 실행 -> 지갑 주소, 등을 확인 | 이게 가나쉬랑 연결❓❓❓ 
# 2nd cli 에서 아래 코드를 실행 

curl -X POST -d '{"jsonrpc" : "2.0", "method" : "eth_sendTransaction","params": [{ "from" : "0x33A58FBba6ec416aAe34c8A8962BaDd748CA431E","to" : "0xd956f2daF656EA2C0ae00683715fCC486d4fC1Aa","value" : "777000"}]}' http://127.0.0.1:8545

    # "from" : "0x134E7aA107b76e32635E8A2E1F7bEc57F6Fc5882" 이건, Available Accounts 를 가져오면 됨
```


# web3 

- web3 공식 문서 : https://web3js.readthedocs.io/en/v1.10.0/


- js 라이브러리 
- 웹 어플리케이션에서 '이더리움, 블록체인' 과 '상호작용' 하기 위해, 'node' 에서 요청을 보낼 때, 'API 를 지정' 해 놓은 것. 
    - 요청이 지정되어 있음. 
    - EX) getBalance 같은 

- ethers.js 도 web3.js 에 포함되어 있음. 




# 간단한 컨트랙트 배포

    - 소스 코드 작성에 사용하는 언어
        - 솔리티디를 사용할 것 임. 
        - [컴파일] 솔리티디 -> evm(이더리움 가상머신) 이 이해할 수 있는 바이트 코드로 '컴파일'
        
        - 배포 진행 -> 트랜잭션 생성 (변환한 바이트 코드와 내용을 포함한 트랜잭션을 생성하고, 이더리움 네트워크에 전송)

        - 네트워크에, 트랜잭션 풀에 담기고, 블록 생성되면서, 데이터로 저장이 된다. -> 스마트 컨트랙트에 배포 

            - 가나쉬는 
                - 트랜잭션이 드러오면 -> 바로 채굴함 -> 그래서 우리가 굳이 마이닝 할 필요 없음. 따라서, 트랜잭션 발생되면, 바로 블록에 담기게 된다. 📛📛📛📛📛📛📛

---


# 기본적인 솔리디티 코드 구조

0. solidity 익스텐션 설치 하고, 작성 시작

1. 라이센스 식별자 
    - 솔리디티를 사용할 수 있게 해주는 것에 대해서 라이센스 식별자를 추가
    - 주석 내용을 라이센스 식별자로 인식

2. 솔리디티 버전

3. 배포할 컨트랙트에 대한 내용
    - 컴파일러 버전이 업데이트 된다고 했을 때, 깨질 수 있는데, 여기에 버전을 명시해서, 컴파일 할 수 있게 



## 솔리디티 컴파일 

``` bash
# solc-js 라이브러리 설치 
    npm i solc@0.8.0    
        # 컴파일 할 때, 버전에서 차이가 나기 때문에, 그냥 solc 로 하면 에러가 남. 
            # 솔리디티로 작성한걸 -> 컴파일 하고 -> evm 이 읽어야 하는데, 솔리디티의 버전과 evm 의 버전이 달라서 에러가 남? ❓❓
            # 따라서, 'test.sol'에서 pragma solidity ^0.8.0; 로 설치해 줬기 때문 때문에, solc 를 0.8.0 으로 설치 해야 함 


# 사용 
# solc 사용해서 코드 컴파일 
npx solc --bin --abi ./test.sol
    #--bin : 코드가 컴파일된 바이트 코드 
        # input 과 output 으로 구분됨 ❓❓❓   
    # abi : 컴파일된 코드의 인터페이스 가 작성된 파일. 이게 bin 에 들어가 있음. | 컴파일된 코드가 어떻게 구성되어 있는지에 대한 설명 | 인터페이스가 작성된 파일
```

