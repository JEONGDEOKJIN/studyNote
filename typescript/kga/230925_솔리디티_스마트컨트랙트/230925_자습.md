# 복습 

## 1. md 파일 복습 #📛 '지금 코드 말고, 개념적인 부분이 어떻게 돌아가는지에 대한 이해가 잘 안 돼'
### contract 실행 #📛 

- 블록에 저장하면, 컨트랙트에 저장할 수 있는 영역 데이터를 영구적으로 저장할 수 있다.

- contract storage에 데이터를 저장한다.

- CA 에서 storage root 를 봤음

- storage 에서 '상태를 유지' 시킬 수 있다. ⭐⭐⭐

	- 블록체인 스마트 컨트랙트에서 상태 관리가 핵심

	- 상태를 저장해서 관리 -> 상태를 다시 조회 할 수 있음

	- 스마트 컨트랙트에는 저장 공간이 있고 -> 그 저장 공간은 영구적이다. ⭐⭐⭐

### 지난주 code 작성 (js class 문법과 비슷)

  

``` javascript

  

class Counter {

    value : string;

    constructor(){};

  

    setValue () {};

  

    getValue () {};

  

}

  

const _counter= new Counter();

{value : 1}

  

const _counter2 = new Counter();

{value : 1}

  

_counter.sevValue(2)

👉 이렇게 하면, counter2 만 바뀜. 다른 counter 는 안 바뀜.

👉 {value : 2}

  

_counter2 의 value 를 보면, 여전히 1 이 됨

👉 {value : 1}

  

그 이유는 인스턴스화 하면 -> 다른 주소에 저장되고 -> 가져온건 주소별로 다르게 가져왔기 때문에

  

```

  
  

- 솔리디티 에서

``` solidity

// SPDX-License-Identifier:MIT

    // 라이센스 버전

  

// 솔리디티 버전

pragma solidity ^0.8.0

  

// 컨트랙트 코드

contract Counter {

    unit256 value;

  

    constructor() {};

  

    function setValue(uint256 _value) public {

        value = _value;

  

    }

    // 수정할 때는 수수로 지불

    // 가스비 계산은 네트워크 환경, 코드 복잡도 등을 고려해서 나옴

    // 우리는 '추정' 할 수 있을 뿐 임.

  
  

    function getValue() public view returns (unit256) {

        // 상태변수를 변경하지 않고 조회 하기 위해 view 를 쓴다.

            // view, pure, 등등 4개 정도 있음.

        return value;

    }

        // 조회는 가스비가 발생하지 않음

  

}

  

```

  
  

- javascript 클래스는 인스턴스를 생성하는 과정에서 new 키워드를 사용

- new 키워드를 통해 생성된 인스턴스들은, 다른 메모리 주소를 참조 하고 있기에, 동일한 객체가 아니다.

  

- solidity 에서의 컨트랙트는, 컴파일된 코드의 내용이, EVM 을 통해서 생성되고, CA 생성될 때, solidity 코드의 내용으로 인스턴스가 한번 생성된다.  

    (어떤 인스턴스를 전역적으로 하나 만들고, 어디서든 사용할 수 있게. 이걸 '⭐싱글톤 디자인 패턴' 돌아갈 때, 그 객체 하나만 사용함. )

  

- 이후에 생성된 인스턴스를 CA 로 참조해서, 컨트랙트에 접근해서 사용하는 데이터는, 같은 데이터를 참조하게 된다. (이게 싱글톤 패턴의 방식)

  
  

- 싱글톤 패턴의 방식 : 인스턴스 객체를 하나 생성해서, -> 전역 객체로 만들고 -> 어디서든, 1개만 만들어서, 생성한 인스턴스만 참조하는 디자인 패턴 ⭐⭐⭐

  
  
  
  

- 스마트 컨트랙트 프로세스

  

1. 컨트랙트 코드를 작성

  

2. 컨트랙트 코드 컴파일  

- bin 파일은 실제로 컴파일 된 내용

  

3. 스마트 컨트랙트 배포 (트랜잭션 생성)

    - (컴파일된) bite 코드를 가지고, 트랜잭션을 생성

  

4. 노드 들에게 전송(트랜잭션을 발생) (broadcast)

    -> 그러면, pool 에 담기게 됨

5. POOL 에서 -> 블록이 생성되고 -> 트랜잭션이 처리됨

  

6. 이때, account 가 만들어짐 (이게 CA 임)

  

7. EVM 에서 솔리디티 코드를 실행해서, 인스턴스를 생성 ❓❓❓ (여기부터 조금😥😥)

  

8. 이때, 상태 변수를 storage 에 데이터 저장 ❓❓❓

    - 그러면, CA 의 상태 변수는 storage root 에 저장

  
  

### 스마트 컨트랙트 코드 구현

- 간단한 카운터를 만들자

  

- 스마트 컨트랙트의 코드가 실행될 때, EVM 에서 연산을 얼마나 할지와, 네트워크의 환경에 따라, '수수료 가스' 가 측정된다.

  

- 네트워크 상황과 코드의 복잡성에 따라 연산(이걸 우리가 직접 연산을 하기는 어려움. 가스비 '추정' 은 가능함.)

  

- 상태 변수 값을 조회하는 함수는 연산 하는 과정이 없기 때문에, 가스비를 필요로 하지 않는다.

  

- 상태 변수의 값을 변경하는 경우에는 연산이 포함된다. (데이터 공간에 대한 변경을 하기 때문에, 자원을 사용함) 그래서, 연산에 따른 가스비를 지불해야 한다.

    - 가스비를 받고, ether 를 조금 태움. 이더리움 생태계를 유지하기 위해서

  

- 연산을 하는 과정에서, 코드의 무한 루프를 연산하게 되면, 과도한 가스비가 발생될 수 있음. 과도한 가스비 방지하기 위해 gasLimit 가 설정되고, gasLimit 가 초과되면 트랜잭션이 블록에 담기지 않는다.  

  
  
  

### 개발 환경 구축

  

``` bash

# 버전 맞춰서 solc 설치

npm i solc@0.8.13

    # 왜냐면, 위에서 설치할 때 그걸 쓴다고 했음

  

# 가나쉬 설치

npm i ganache-cli

    # 전역으로 설치한 경우 필요는 없음

  

```






# [복습] 컨트랙트 배포 

## '스마트 컨트랙트 배포' 및 '배포한 컨트랙트 실행' 프로세스 요약

``` bash 
[스마트 컨트랙트 배포]
	1. 컨트랙트 코드를 작성 
		- sol 확장자 
		- 라이센스 명시, 버전 명시 등 정리 필요 #✅
	
	2.  컨트랙트 코드 컴파일  
	- bin 파일은 실제로 컴파일 된 내용 
	
	3. 스마트 컨트랙트 배포 (트랜잭션 생성)
	    - (컴파일된) bite 코드를 가지고, 트랜잭션을 생성
	    - 'web3.eth.sendTransaction' 을 통해 'ganache' 테스트 환경에서 실행함 
	    - 따라서, 요청이 가면, 별도 과정없이, 'POOL 에서 -> 블록이 생성되고 -> 트랜잭션이 처리됨' 

	4. 생성된 CA 확인
		- 이 결과 CA 가 만들어짐 
		- CA 의 상태 변수는 storage root 에 저장

	 5. abi 를 사용해서 컨트랙트 코드를 정의하고 실행 | [배포한 스마트 컨트랙트 실행 위해 abi 변수 만들기]
		- abi 를 사용하는 이유? 
			- '스마트 컨트랙트가 배포' 되었다는 건, 'solidity 로 작성된 파일이 바이트 코드로 컴파일 되고 -> ganache 테스트 환경에서 -> EVM 안으로 들어가, 연산이 처리되고 -> 그 결과가 반환' 된 상태임. 
			- 이렇게 '최초 스마트 컨트랙트 실행' 된 이후에,  'solidity 파일 -> 바이트 코드 컴파일 -> ganache 환경에서 EVM 안에서 처리' 되는 과정을, 다루기 위해, abi 가 사용됨 ⭐⭐⭐⭐⭐ 
			- 즉, low-level 로 컴파일되어, EVM 에서 작동되는 '연산, 데이터 저장' 등에 접근해서, 원하는 결과를 가져오기 위한 것 .
		- 컴파일 결과 나온 ABI 확장자 내 파일을 가져와서 'const abi = [ ]' 이 안에 담아 놓는다. 


	6. getValue 로 상태변수 '조회' 하기 


	7. setValue 로 상태변수 '변경' 하기 




CF. CALL VS SEND 비교
- call() : 원격 프로세저에서 '값을 받아올 때', '값을 조회' | 가스비 발생 안 함 -> so, from 이 없음 ⭐⭐⭐, to 만 있음. 
	// to 는 CA 에 요청을 보냄 
- send() : 원격 프로세저에서, '값을 변경할 때', 

```



## 1. 컨트랙트 코드 작성
- 설명 
``` bash
- solidity 언어로, 원하는 로직(기능) 을 작성 
```

- `Counter.sol` 에 이렇게 작성함 👇
``` sol 
// SPDX-License-Identifier:MIT  
	// 라이센스를 명시

pragma solidity ^0.8.13;
	//  solidity 버전 명시 -> 이 버전으로 solc 를 설치해서, 컴파일 시도 

// Counter 라는 이름의 '스마트 컨트랙트' 를 정의 ⭐⭐⭐ 
contract Counter {
	// unit256 타입의 '상태변수' 인 value 를 정의 
    uint256 value;
	    // [해석] ⭐⭐⭐⭐⭐
		    // 1) '상태 변수' 로 정의 되면 -> '스마트 컨트랙트 내에 저장' 되는 변수 임 
		    // 2) 'Ethereum의 storage' 에 영구적으로 저장 된다. 

    constructor(){}

    function setValue(uint256 _value) public{
        // 상태 변수 변경
        value = _value;
    }

    function getValue() public view returns(uint256)  {
        return value;
    }
}
```


<br>

## 2. 컨트랙트 코드 '컴파일'

``` bash
# solc 로 '컴파일' ⭐⭐⭐
- npx solc --bin --abi '파일의 경로'
- ex) npx solc --bin --abi Counter.sol
```

<br>

## 3. 스마트 컨트랙트 배포 (트랜잭션 생성)
```
- (컴파일된) bite 코드를 가지고, 트랜잭션을 생성
```


``` js 
    // bin 파일에 컴파일된 컨트랙트 코드 내용 (트랜잭션 생성시 필요)
    sendTransactionBtn.onclick = () => {
        web3.eth.sendTransaction({
            // input 에 넣은, '컨트랙트 배포자 계정' 이 들어감 | 컨트랙트를 배포할 때, 수수료를 지불할, 컨트랙트 배포자 계정 ⭐⭐⭐⭐⭐
            from: useAccount.value,

            // 가스 제한량
            gas: "300000",

            // 컴파일된 컨트랙트 내용이 바이트 코드 로 들어감 
            data: contract.value
                /*  1. textArea 에 있는 useContract 안에, 컴파일된 bin 파일 내용을 복붙해서 넣는다. 
                    2. 그러면, sendTransaction 메소드(이더리움에서, transaction 발생 시키기 위한 메소드) 에 필요한 매개변수를 채우게 된다. 
                */
        }).then(console.log);
```



## 4. 컨트랙트 배포 후 CA 받기 
``` JS
// 4. 컨트랙트 배포 후, 트랜잭션 처리가 되면, 응답으로 컨트랙트 주소를 주는데 CA (컨트랙트 계정)
	// 컨트랙트 참조에 사용하는 주소 CA ❓❓❓❓❓ 
	// 가나쉬는 블록이 발생되면 -> 바로 생성되버림 ⭐⭐⭐⭐⭐⭐
	// CA : "0x1fF0d88C60Ba1CC740162F69c2E5D4E97152F41d"
```


<br>

## 5. 배포한 스마트 컨트랙트 실행 위해 abi 변수 만들기
``` JS 
    // 5. 배포한 컨트랙스 실행 
        // 이 객체 구조를 정의할 때 필요한 abi ⭐⭐⭐ 
        // abi 를 사용해서 컨트랙트 코드를 정의하고 실행 
        // interface 가 필요함 
            // 인터페이스 쓴 이유는 "정의한 구조대로 사용하기 위해서"
            // 그러면, 우리는 그 구조에 맞게 따라서, 사용해야 함 ⭐⭐⭐ 
            // 이 인터페이스를 사용하겠다는 말! 

        const abi = [
            // 생성자 함수
            { inputs: [], stateMutability: "nonpayable", type: "constructor" },
                // inputs: [] : 이건 매개 변수 임. 매개변수 받지 않으니까 비어있음. 
                // stateMutability: "nonpayable" : 이더리움 전송하지 않겠다. 이더리움 받지 않는 상태 전환 함수 
                    // payable : 이더를 전달 받을 수 있는 '상태 변환 함수' | value 로 받을거냐, 안 받을거냐 
                    // CA 에도 balance 가 있음. ca 에도 잔액이 있다는 말
                    // 함수를 실행했을 때, 이더리움을 실행할 수 있는지  
                // type: "constructor" 이 함수의 타입은 생성자 함수임

            
            { 
                inputs: [], // 매개변수를 안 받으니까, 빈 문자열 
                name: "getValue",   // 함수 이름 
                
                // outputs : 함수의 출력 내용  
                outputs: [{ 
                    internalType: "uint256",    // '상태 변수의 함수의 값' 에 대한 타입
                    name: "",       // 사용하는 매개변수의 이름 -> 쓰는 매개변수가 없으니 비어있음. 
                    type: "uint256"     // 반환하는 반환값 타입 
                }], 
                
                // 함수에 어떤 속성이 있는지
                    // view 말고도, pure 등이 있음. 
                    // view : 상태 변경을 하지 않고, view 속성 조회만 한다. ⭐⭐ 
                stateMutability: "view", 

                // 함수의 타입은 function 함수 타입이다! 
                type: "function" 
            },
            { 
                // 매개변수를 받음 
                inputs: [{ 
                    internalType: "uint256", // internalType 함수의 값에 대한 타입
                    name: "_value",     // 사용하는 매개변수의 이름  
                    type: "uint256" 
                }], 
                name: "setValue",   // 사용하는 함수 이름 
                
                // 함수의 출력은 없으니까 []
                outputs: [], 
                stateMutability: "nonpayable", // 이더리움 받지 않는 상태 전환 함수 
            
                type: "function" },     // 함수 타입 == function 
        ];
```

<br>

## 6. getValue 로 상태변수 '조회' 하기 | ⭐⭐목표는 상태 변수로서 저장소에 저장되어 있는 value 값 가져오기 
``` js 
        // 카운트의 값을 조회하는 함수 | 목표는 상태 변수로서 저장소에 저장되어 있는 value 값 가져오기 
        const getValue = async() => {

            // 1. solidity 파일에 적은 getValue 함수를 hash 화 시키기             
            const getCodeHash = web3.eth.abi.encodeFunctionCall(abi[1] , [])   
                // evm 에서 돌아갈 수 있는 hash 값으로 우선 변경되어야 함            
                // encodeFunctionCall 16진수 문자열을 반환
                // 컨트랙트 함수의 내용과 우리가 전달할 매개변수를 전달해서 해시코드로 변환
                // EVM 에서 실행을 시킨다. 
                // 조회할 거니까, 2번재는 비워둠

                // encodeFunctionCall
                    // 첫 번째 매개변수 : 실행시키고 싶은 함수의 interface 를 전달 
                        // 이 interface 는 컴파일 된 것이 어떤 구조를 갖고 있는지를 의미❓ 
                    // 두 번째 매개변수 : 함수에 전달할 매개변수 값
            console.log("abi[1] 인 getValue 함수를 hash 화 시키기 : " , getCodeHash)


            // 2. hash 화 된 getValue 함수를 web3 라이브러리를 통해 EVM 으로 넘겨서 value 값 가져오기
            const data = await web3.eth.call({
                to : "0x1fF0d88C60Ba1CC740162F69c2E5D4E97152F41d",  // 아까 받아온 ca
                data : getCodeHash, // 16진수로 변화된 값이 넘어옴
            })
                // call() : 원격 프로세저에서 '값을 받아올 때', '값을 조회' | 가스비 발생 안 함 -> so, from 이 없음 ⭐⭐⭐, to 만 있음. 
                    // to 는 CA 에 요청을 보냄 
                // send() : 원격 프로세저에서, '값을 변경할 때', 

            console.log("EVM에게서 받은 16진수 value 값" ,data)  // data 에는 16진수
        
            // 3. 받아온 16진수를 10진수로 
            const result = await web3.utils.toBN(data).toString(10)
            
            console.log(result)
                // 이 값은 0 임 
                // 여기에서 이제 상태변수가 나온 것 임.  

            // 4. 받아온 걸 렌더링 해주기 
            counterValue.innerHTML = result;
            return parseInt(result);
        };


```

<br>

## 7. setValue 로 상태변수 '변경' 하기 | ⭐⭐목표는 상태 변수로서 저장소에 저장되어 있는 value 변경해보기 
``` js 
        // 7. setValue 로 상태 변수 변경 
            // 이때는 가스비 발생! 함 
        const setValue  = async() => {

            // 1) 현재 상태변수 value 에 있는 값 가져오기 
            const _getValue = await getValue()

            // 2) solidity 파일에 적은 setValue 함수를 hash 화 시키기             
            const setCodeHash = await web3.eth.abi.encodeFunctionCall(abi[2] , [_getValue + 1] )
                // 컴파일 된 abi 중 사용할 함수 set Value 쓸거니가 2 
                // _getValue + 1 지금 현재 값에서 +1 된 값을 넣기! ❓❓❓❓❓❓❓❓❓❓
            
            console.log(setCodeHash)
            // 0X6123546000000000000000000000000000000
                // 사이에 있는 0의 값은 의미 없는 값 임. 
                // 구분 짓기 위해 사용! 구분자로 사용!

            // 3) 컨트랙트 배포자 계정 | 수수료가 지불될 계정임 ⭐⭐⭐⭐⭐⭐
            if(!useAccount.value) return alert("Account 입력 하셈")


            // 4) 트랜잭션 | '누가, 누구에게, 얼마를, '
            const tx = {
                from : useAccount.value,    // 트랜잭션을 발생시키는 계정
                to : "0x1fF0d88C60Ba1CC740162F69c2E5D4E97152F41d",   // 누가 받았냐, CA계정 주소 
                data : setCodeHash,     // solidity 파일에 적은, hash화된, setValue 함수,
                gas : 500000,       // gas 총량
                gasPrice : 200000000,       // gas 당 가격
            
            };


            // 5) web3 라이브러리를 통해, sendTransaction 메소드 실행 시키기
            const data = await web3.eth.sendTransaction(tx)
            console.log(data);


            // 6) setValue 로 변화 시키고 난 다음, 상태변수 value 값 가져오기 
            getValue();
        }

```



<br>

## 8. react 에서 스마트 컨트랙트 배포 해보기 




- 포인트 
``` bash
- 리액트 셋팅 

- ⭐⭐ '메타마스크와 브라우저 간 연동' 하게 하는것 포인트 
```
























# 이더리움의 구성요소 (feat. 비트코인 구성 요소와의 비교)

- GPT 링크 : https://chat.openai.com/share/a05e54ce-da81-45a9-87d4-b6ff2d945848


## Bitcoin 노드의 주요 구성 요소
``` BASH
1. 블록체인 (Chain): '모든 거래의 히스토리'를 포함하는 '블록'들의 '연속체'

2. UTXO : Unspent Transaction Output
	- 현재, 사용 가능한 잔액들이 모여 있음. 

3. 트랜잭션 풀(Transaction Pool) : 블록에 포함되지 않은 트랜잭션, 들을 저장하는 공간. 

4. 기타 : P2P 프로토콜, 보안, 합의 메커니즘, 지갑 관리 
```


## Ethereum 노드의 주요 구성 요소 |  #📛📛(EOA, CA 예시를 아직 잘 모르겠음) 
``` bash 
1. 블록체인 (Chain): '모든 거래' 및 '스마트 컨트랙트' 의 히스토리를 포함하는 '블록'들의 '연속체'

2. 상태(state) : '모든 계정 정보'  가 저장됨. ⭐⭐ 
	- 상태(state) 의 주요 구성 요소 
		a) 'EOA' (Externally Owned Accounts)
			- '개인키' 에 의해 제어된다. ex) 개인키가 있어야만, 원하는 계정으로 트랜잭션을 전송할 수 있음. 
				- '개인의 지갑' 같은 의미
			- 직접 코드를 실행할 수 없음. 
		b) 'CA' (Contract Address)
			- '스마트 컨트랙트' 를 위한 계정
				- 스마트 컨트랙트가 설정될 때, '한번만!' 설정됨

3. 트랜잭션 풀(Transaction Pool) : 블록에 포함되지 않은 트랜잭션, 들을 저장하는 공간. 

4. EVM : Ethereum virtual Machine 
	- '솔리디티 등으로 작성된 스마트 컨트랙트 파일' 을 실행시키려면? 
		1) 컴파일 을 함 
		2) EVM 바이트 코드(저수준 언어) 로 변환되어 있음. 
		3) 이 저수준 언어(EVM 바이트 코드) 는 '이더리움 네트워크' 에서 직접 실행될 수 있음. 
			- 그 다음이 안 그려져 😥😥 
			- 컴파일을 한 뒤에 어디로 가? 
				- 오늘 예제 에서는 
					1) '컴파일된 bin 파일' 은 '사용자가 useContract' 에 'bin 파일을 복붙' 하면 
					2) web3.eth.sendTransaction 의 매개변수로 들어가게 해놨음 ⭐⭐⭐⭐⭐
					3) 그러면, 'web3 라이브러리' 를 활용해서 'RPC' 통신을 통해, '이더리움 네트워크' 의 'sendTransaction' 을 사용함 

5. 스토리지 (저장소)
	- 스마트 컨트랙트의 '상태 변수' 와 '데이터' 를 저장하는 영역 

6. 기타 : P2P 프로토콜, 가스 매커니즘, 합의 메커니즘, 지갑 관리 

```


## bitcoin VS ethereum 비교 

``` bash
[bitcoin 특징]
- '거래' 와 'UTXO' 관리에 초점 

[Ethereum]
- '스마트 컨트랙트' 
- 스마트 컨트랙트를 실행하기 위한 'EVM' 
- EVM 을 통해 처리되는 대상 : '상태 변수', '저장소'
```



<br>

# 'web3.eth.sendTransaction' 를 호출하면, '원격 RPC' 에 의해, '다른 노드 안에 있는 sendTransaction' 를 사용한다고 하는데, 구체적으로, 어떤 순서대로, 작동하는거지?  |  #✅(좀 더 복습하면 좋을 것 같음⭐⭐⭐)  #⭐⭐⭐ 

``` bash
1. 'web3.eth.sendTransaction' 을 호출함 

2. 해당 호출은 '로컬 노드' 에 전달된다. 
	1) '로컬 노드' 가 'web3.eth.sendTransaction을 호출한 내 PC(노드)' 일 수도 있고 
	2) '로컬 노드' 가 '다른 노드(PC)' 일 수도 있고
	
	이게 결정되는 순간은 👇👇👇 여기 아래 임. | web3 라이브러리를 불러올 때, 어떤 주소와 연결시켜줄거냐? 라는 것에서 결정됨.  
		
			    // 네트워크 연결 ⭐
		    const web3 = new Web3("http://127.0.0.1:8545") ⭐⭐⭐ 이것 때문에, 'web3 라이브러리 호출의 엔드포인트는 8545 포트를 쓰는 ganache'  ⭐⭐⭐ 
		        /*  [포인트]
		            - (전제) web3 로 RPC 통신을 할 때, '원격(다른 노드)' 으로 접속해서, 해당 노드에서 이미 정의되어 있는 걸 쓴다고 했음. 
		            - 그럼, '구체적으로 어떤 노드와 통신하는거야?' 라고 했을 때, 
		                - 현재, http://127.0.0.1:8545 여기와 연결시켜 두었음. 
		                - 그 말은, 8545는 ganache 가 주로 사용하는 포트 이므로, '⭐⭐⭐로컬(내PC) 로 실행되는 Ganache 노드' 와 통신한다는 의미. 
		            - 만약, 테스트넷, 메인넷이면 이곳에 다른 주소가 들어감 ⭐
		        */

3. web3 라이브러리를 통해, '로컬 ganache 노드' 안에 있는 sendTransaction 이 실행된다.
	- '이 순간' 로컬 ganache 노드는 '트랜잭션을 처리' 한다. -> 그리고 그 결과를 web3 에 반환 한다. 
	
4. '로컬 ganache 노드' 가 트랜잭션을 처리하는 과정을 좀 더 상세히 보면?⭐
	1) 'web3.eth.sendTransaction을 호출' 하면, 매개변수가 들어간 '객체' 가 생성됨
	2) '트랜잭션 검증' : ganache 노드는 송신자의 잔액, 서명의 유효성 등을 검증 
	3) '트랜잭션 실행' : ganache 노드는 EVM 내에서 트랜잭션을 실행한다. #📛  (이 과정이 명확히 잘 안 그려짐) 
	4) EVM 에서 벌어지는 일 요약 
		- '트랜잭션이 포함된 low-level 의 바이크 코드' 를 input 으로 받고 
		- '스택, 메모리, 저장소' 등의 저장공간을 활용한 '연산' , '바이트 코드 명령어' , '상태 변경' 등의 process 를 거치고 -> 각 output 을 '이더리움(그에 상응하는 ganache)' 에 '알려준다.(통신)' 		
	5) '가스 소비' 계산
		- EVM 에서 트랜잭션 처리를 할 때, 다양한 연산이 발생됨. 
		- 단순 조회는 가스비를 발생시키지 않음 
		- '상태 변경' 을 할 때는, 가스비를 지불함. 

	6) '트랜잭션 영수증' 생성 
		- 사용된 가스, 트랜잭션 상태(성공 or 실패) 등이 포함됨. 

	7) '블록' 에 포함 | ganache 는 곧바로, 블록이 생성됨 ⭐⭐⭐ 
		- ganache 는 '테스트 환경' 이기 때문에, 'a) 트랜잭션 풀에 올리고 -> b) 채굴하고 -> c) 합의 알고리즘으로 권한 설정하고, 검증하고 -> d) 권한 획득한 노드가 블록에 기입하는 과정' 이 없음 ⭐⭐⭐⭐⭐

	8) 상태 업데이트 
		- '트랜잭션'이 성공적으로 처리되면, '이더리움의 상태' 는 트랜잭션 결과에 따라, '업데이트' 된다. 


5. EVM 내에서 벌어지는 일을 좀 더 자세히 살펴보면? 
	1) input  
		a) 컴파일된, low-level 의 스마트 컨트랙트 바이트코드 
		b) 트랜잭션 ex) 입력된 데이터, 함수 인자 
	2) process ⭐⭐⭐ 
		a) '스택, 메모리, 저장소' 같은 다양한 '데이터 저장 공간' 활용한 '연산' 수행 
		b) '바이트 코드 명령어' 를 수행
		c) '상태 변경' 필요한 경우, 상태 변경 ex) 이더 전송, 저장소 업데이트 ⭐⭐⭐  
	3) output 
		a) '데이터 저장공간' 을 활용한 연산 결과 
		b) 상태 변경 결과 ex) 이더리운 잔액 변경, 스마트 컨트랙트 변수 업데이트
		c) 오류 메시지 ex) 가스비 부족 등 
	4) 통신 ⭐⭐⭐
		a) EVM 이 수행 결과를 '이더리움(그에 상응하는 ganache)' 에 알려준다. 

```


