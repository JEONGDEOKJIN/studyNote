# contract 실행 

- 블록에 저장하면, 컨트랙트에 저장할 수 있는 영역 데이터를 영구적으로 저장할 수 있다. 
- contract storage에 데이터를 저장한다. 
- CA 에서 storage root 를 봤음 
- storage 에서 '상태를 유지' 시킬 수 있다. ⭐⭐⭐ 
    - 블록체인 스마트 컨트랙트에서 상태 관리가 핵심 
    - 상태를 저장해서 관리 -> 상태를 다시 조회 할 수 있음 
    - 스마트 컨트랙트에는 저장 공간이 있고 -> 그 저장 공간은 영구적이다. ⭐⭐⭐ 

# 지난주 code 작성 (js class 문법과 비슷)

``` javascript

class Counter {
    
    value : string;
    constructor(){}; 

    setValue () {};

    getValue () {};

}

const _counter2 = new Counter();
{value : 1}

const _counter1 = new Counter();
{value : 1}

_counter.sevValue(2)
👉 이렇게 하면, counter2 만 바뀜. 다른 counter 는 안 바뀜. 

_counter

```


- 솔리디티 에서 
``` solidity
// SPDX-License-Identifier:MIT
    // 라이센스 버전

// 솔리디티 버전
pragma solidity ^0.8.0

// 컨트랙트 코드
contract Counter {
    unit256 value;

    constructor() {};

    function setValue(uint256 _value) public {
        value = _value;

    }
    // 수정할 때는 수수로 지불
    // 가스비 계산은 네트워크 환경, 코드 복잡도 등을 고려해서 나옴 
    // 우리는 '추정' 할 수 있을 뿐 임. 


    function getValue() public view returns (unit256) {
        // 상태변수를 변경하지 않고 조회 하기 위해 view 를 쓴다. 
            // view, pure, 등등 4개 정도 있음. 
        
        return value;
    }
        // 조회는 가스비가 발생하지 않음
        

}

```


- javascript 클래스는 인스턴스를 생성하는 과정에서 new 키워드를 사용
- new 키워드를 통해 생성된 인스턴스들은, 다른 메모리 주소를 참조 하고 있기에, 동일한 객체가 아니다. 

- solidity 에서의 컨트랙트는, 컴파일된 코드의 내용이, EVM 을 통해서 생성되고, CA 생성될 때, solidity 코드의 내용으로 인스턴스가 한번 생성된다.  
    (어떤 인스턴스를 전역적으로 하나 만들고, 어디서든 사용할 수 있게. 이걸 '⭐싱글톤 디자인 패턴' 돌아갈 때, 그 객체 하나만 사용함. )

- 이후에 생성된 인스턴스를 CA 로 참조해서, 컨트랙트에 접근해서 사용하는 데이터는, 같은 데이터를 참조하게 된다. (이게 싱글톤 패턴의 방식)


- 싱글톤 패턴의 방식 : 인스턴스 객체를 하나 생성해서, -> 전역 객체로 만들고 -> 어디서든, 1개만 만들어서, 생성한 인스턴스만 참조하는 디자인 패턴 ⭐⭐⭐ 




- 스마트 컨트랙트 프로세스 

1. 컨트랙트 코드를 작성 

2. 컨트랙트 코드 컴파일  
- bin 파일은 실제로 컴파일 된 내용 

3. 스마트 컨트랙트 배포 (트랜잭션 생성)
    - (컴파일된) bite 코드를 가지고, 트랜잭션을 생성

4. 노드 들에게 전송(트랜잭션을 발생) (broadcast)
    -> 그러면, pool 에 담기게 됨 
    
5. POOL 에서 -> 블록이 생성되고 -> 트랜잭션이 처리됨 

6. 이때, account 가 만들어짐 (이게 CA 임)

7. EVM 에서 솔리디티 코드를 실행해서, 인스턴스를 생성 ❓❓❓ (여기부터 조금😥😥)

8. 이때, 상태 변수를 storage 에 데이터 저장 ❓❓❓ 
    - 그러면, CA 의 상태 변수는 storage root 에 저장


# 스마트 컨트랙트 코드 구현 
- 간단한 카운터를 만들자 

- 스마트 컨트랙트의 코드가 실행될 때, EVM 에서 연산을 얼마나 할지와, 네트워크의 환경에 따라, '수수료 가스' 가 측정된다. 

- 네트워크 상황과 코드의 복잡성에 따라 연산(이걸 우리가 직접 연산을 하기는 어려움. 가스비 '추정' 은 가능함.)

- 상태 변수 값을 조회하는 함수는 연산 하는 과정이 없기 때문에, 가스비를 필요로 하지 않는다. 

- 상태 변수의 값을 변경하는 경우에는 연산이 포함된다. (데이터 공간에 대한 변경을 하기 때문에, 자원을 사용함) 그래서, 연산에 따른 가스비를 지불해야 한다. 
    - 가스비를 받고, ether 를 조금 태움. 이더리움 생태계를 유지하기 위해서 

- 연산을 하는 과정에서, 코드의 무한 루프를 연산하게 되면, 과도한 가스비가 발생될 수 있음. 과도한 가스비 방지하기 위해 gasLimit 가 설정되고, gasLimit 가 초과되면 트랜잭션이 블록에 담기지 않는다.  

