

# 비트코인 
    - 디지털 화폐, p2p 거래를 하기 위해서, 제안 되었음. 
    - 디지털 화폐로써, 전자 지불 수단, 으로써 제안!!! 
    - 비트코인은 블록의 생성시간이 10분
    - 총 공급량은 21백만개 정도


# 이더리움 
    - [특징]
        - 비트코인과 다르게 '스마트 컨트랙트' 및 'Dapp 개발' 을 할 수 있음. 
        - 블록 생성시간이 15초 ~ 20초 정도 
        - 빠른 처리로 스마트 컨트랙트 실행이 가능한 환경
        - 공급량이 처음에 제한이 없었는데, 나중엔 공급량이 조금 감소되도록 제한 
            - 어떤 공급량 ❓❓
    

        - '스마트 컨트랙트' 를 구현할 수 있음. 
            - 비트코인
                - 돈을 받고, 보내고, 만 있음. 간단한 트랜잭션만! 
                - 누가, 누구에게, 전송
                - 스마트 컨트랙트가 없음. 
            - 이더리움 
                - 스마트 컨트랙트를 구현. A 계정에서 B 계정을 통해 C 의 상품을 구매할 수 있는 내용을 작성할 수 있음.
                - 코드를 조금 더 추가할 수 있어! ⭐⭐⭐
                    - EX) B계정을 통해 C 상품 구매하는 코드를 작성할 수 있음. 
                - B가 A에게 상품 금액 전달받고, C에게 알려주면, C는 A에게 상품을 전달하고, A는 C의 상품을 받으면, 스마트 컨트랙트가 동작해서, B 의 계정에 C 의 계정으로 돈을 송금한다.
            - 비트코인 VS 이더리움 
                - 비트코인 : 단순 자산 전송 
                - 이더리움 : 조건을 작성할 수 있는 계약의 거래 형태. '스마트 컨트랙트' 라고 부른다. ⭐⭐
                    - 이더리움은 EVM 이라는 '가상 머신' 이 있음. 그래서 스마트 컨트랙트 코드를 실행시킴. 
                    - 윈도우인데 리눅스 실행하고 싶으면 가상 머신 열었잖아? 
                    - 마찬가지로, 동일한 코드 결과를 얻기 위해, 이더리움 가상머신은 EVM 임. 
            - 스마트 컨트랙트를 활용하면, 돈을 전송하고 받는 거래가 아닌, 조건에 맞는 코드를 동작시켜, 기능을 추가할 수 있음! 
            - 스마트 컨트랙트 코드는 EVM 이더리움 가상 머신 내부에 저장된다. 
                - 코드가 해시의 형태로 저장된다. ⭐⭐
            

        - 이더리움 백서 
            - 스택적인 기술은 비트코인에서 배우고 와라 라는 느낌
            - 이더리움은 '계약' 에 대한 내용이 중요 



# EVN 
    - 이더리움에서 중요한 내용 ⭐⭐⭐

    - 가상머신 
        - 하나의 물리적인 컴퓨터 안에서, 다른 운영체재나 프로그램을 실행할 수 있게 해준다. EX) 윈도우에서 리눅스 쓸 수 있게 해주는 

        - 이더리움 가상머신은, 이더리움 블록체인 네트워크에서, '스마트 컨트랙트 코드' 를 작성하고 실행하는데, EVM 이 있는 이유는, 모든 OS 환경에서 '똑같은 코드의 동작이 실행' 되어야 하고, '동일한 결과' 를 출력해야 하기 때문에 ⭐⭐

        - ⭐똑같은 결과⭐를 갖고 합의를 해야 하는데, 서로 다른 합의를 내놓고 있으면, 합의하기 어려울 거야. -> 그래서, EVM 머신 개발을 해서, 어디서든 같은 결과를 갖고 합의 하려고 ⭐⭐⭐

        - 이더리움 네트워크는 스마트 컨트랙트 코드를 컴파일 하고, EVM 을 통해 실행시킨다. 
        - EVM 은 컴파일된 바이트 코드를 실행, 바이트 코드로 컴파일 할 수 있는 코드라면, 언어에 상관이 없이, ⭐⭐EVM 을 통해 같은 결과물을 얻을 수 있다⭐⭐
        > 그렇기 때문에, ⭐⭐ EVM 이 있기 때문에, 스마트 컨트랙트를 실행시키고, 같은 결과물을 얻을 수 있어 ⭐⭐⭐

        - 즉, (BY DJ) 이더리움에서 중요한건 '스마트 컨트랙트' 임. 
            - '코드' 로 작성해놓고 -> 작성된 코드를 '컴파일' 해야 하니까 'EVM' 이라는 가상머신이 필요하고 
            - EVM 을 통하면, 어떠한 환경에서건 동일한 결과를 얻을 수 있다는 것


# 1. 스마트 컨트랙트 코드 작성

# 2. 바이트 코드로 컴파일

# 3. EVM 에서 컴파일된 코드를 실행

- 이더리움이 스마트 컨트랙트를 실행할 수 있는 핵심 요소는 
    EVM(이더리움 가상머신) 가상의 컴퓨터가 노드에 존재하기 때문에. 

- 전역 상태에 대한 내용은 EVM 에 들어있어. 이더리움이 정의한 규칙에 맞게, 스마트 컨트랙트를 실행하고, 결과를 상태에 업데이트 하는 작업을 수행한다. 

- EVM 은 블록체인의 분산 네트워크에 참여하고 있는 모든 노드들이, 같은 합의를 이루어주기 위해 있음. 
    - 어느 환경에서든 똑같은 코드가 나올 수 있게 

    - 각자 노드가 있고, 노드에서 스마트 컨트랙트가 실행 -> 각자 상태를 업데이트 -> 노드들이 같은 상태의 합의를 이룰 수 있도록 한다. 

    - EVM 은 블록체인 분산 네트워크에 참여하고 있는 모든 노드들, 같은 상태의 합의를 이룰 수 있도록, 내용이 같은 코드를 실행할 때 
    
    - 각자 실행하는 환경이 달라서, 다른 결과물을 얻으면, '네트워크라는 하나의 상태의 합의' 를 이룰 수 없다. 

    - 똑같은 결과물을 뽑을 수 있는 이유는 EVM 때문이다 ⭐⭐⭐

    - EVM 네트워크의 모든 노드는 같은 코드를 실행해서, 같은 결과를 얻기 위해, ⭐⭐EVM 을 통해 실행⭐⭐ 시킨다. 그래서 모든 노드들은 트랜잭션과 스마트컨트랙스를 각자의 EVN 에서 실행시키고, 블록체인의 전체 상태를, 다른 노드를과 동일하게 유지시킬 수 있다. 


    Solidity code -> 이더리움 컴파일러 -> EVM 

    배포한 컨트랙트의 주소 와, CA 가 맵핑이 됨. 

    배포 -> 트랜잭션 주소가 생김 . 코드의 내용은 EVM 이라는 가상 머신에 저장 
    가상 머신에 저장된 걸 실행하려면, CA ? 에 접근? 
    직접 접근하는건 힘들어서 CORS 해야ㅠㅠㅠ 

    어려우니까, PRODIVDE 로 진행

    실제 네트워크에 직접 요청을 보낼 수 없음 😥😥 응? 


    즉, EVM 포인트 정리 
        가상 머신 
        컨트랙트 코드(커파일된 코드) 가 있음. | 다른 환경에서도 동일한 결과 얻으려고 사용


# 이더리움 Account

    - 이더리움 네트워크에 EOA 와 CA 라는 두 개념이 있고, 각각의 역할은 

    - 비트코인에서도, 서명을 어떻게 하느냐에 따라, 스마트 컨트랙트도 가능하긴 했었음 
    - 그래서, 계약을 
    - UTXO 잔액으로 '트랜잭션 out' 으로 넣어줌 

    - in 으로 10개, out 되면 -> 상태가 업데이트 된다. 라고 받아들임 -> 이 상태를 작성한게, 스마트 컨트랙트, (알발라 ?)
    - 스마트 컨트랙트는 '코드' 로 작성하게 한거고 
    - '코드' 니까, '런타임' 이 필요 -> so, EVM 을 만듦 -> EVM 을 통해 실행


    - ACCOUNT 에 업데이트 된 상태를 저장함. 

## EOA (ACCOUNT 에 있는 하위 요소)
    - 외부 소유 계정 
    - 지갑 처럼 
    - 특징
        1. 개인키가 있고, 지갑 계정으로 코드에 저장하지 않음
        2. 자금 또는 스마트 컨트랙트 코드에 접근 제어 

        3. EOA 에서 트랜잭션 생성 
            - 무조건 EOA 에서 트랜잭션 시작 ⭐⭐⭐
            - EOA 또른 CA 에, 트랜잭션 보낼 수 있고, 개인키를 사용해서, 트랜잭션을 생성 및 서명! 
        
        4. EOA 에서 발생하는 트랜잭션은 'EOA에서 EOA 로 전송하면' 돈 전송! 하는 개념임

        EOA 에서 CA 로 트랜잭션을 생성하면, CA 의 코드를 동작시킨다. 
        CA 는 배포한 스마트 컨트랙트의 주소임. 
        그 주소에 컨트랙트를 발생시키면, 붐 

        (EOA -> CA) EOA 가 전송한 트랜잭션을 시작된다. 
        무조건 EOA 에서 트랜잭션이 시작되고 -> CA 로 전송되고 -> 그 다음 CA 로 

        EOA 는 지갑 계정에 대한 Account 임. 
        
### CA 는 계약의 주소 
    1. 스마트 컨트랙트 로직으로, 스마트 컨트랙트 코드를 해시 내용으로 저장. 

    2. 개인키가 없고, 스스로 트랜잭션을 발생시킬 수 없다. 
    
    3. 외부 트랜잭션의 응답으로 트랜잭션을 실행할 수 있다. 

    CA 는 EOA 와 다르게, 개인키가, 없고, 스스로, 트랜잭션을, 생성할 수 없다. 

    CA 는 다른 응답으로만 실행시킬 수 있다? 😥😥😥


    - CA 혼자 트랜잭션을 발생 시킬 수 없음. EOA 가 실행 시켜야 함 
        CA -> EOA (X) 

        EOA -> CA(O)
            - EOA 에서 트랜잭션 시작 -> CA 로 가는거 OK

        EOA -> CA -> CA
            - CA 는 다른 CA 나 EOA 에서 받은 트랜잭션의 응답으로, 트랜잭션을 실행시킬 수 있다. 
            
        EOA -> EOA 트랜잭션을 발생 (금액을 송금)

        EOA -> CA (스마트 계약 코드를 실행)(트랜잭션 처리 -> EVM 을 통해 스마트 컨트랙트 코드를 실행)


### EOA 구조 (외부 소유 계정)


#### 트랜잭션 객체의 구성
    - from : 트랜잭션 발생시킨 계정 | 보내는 계정 
    - to : 트랜잭션 받는 계정 | EOA 또는 CA 
            - EOA 면 : 금액 전송 ⭐⭐⭐
            - CA 면 : 계약 코드를 실행 ⭐⭐⭐
    
    - nonce : 보내는 계정이 발생시킨 트랜잭션 횟수
        - 처음에 EOA 계정이 생성되면, 초기값은 0 
        - 트랜잭션을 발생시킬 때 마다, 증가
        - nonce 값이 있는 이유? 
            - ex) 트랜잭션 1 : nonce 1 
            - ex) 트랜잭션 2 : nonce 2 
            - ex) 트랜잭션 3 : nonce 3 
            👉 ⭐'중복되지 않고'⭐, 순차적으로 처리함 

        - 논스가 있는 이유는? ⭐⭐
            - 중복되지 않고, 순차적으로, 트랜잭션을 처리하기 위해서
            - 어떤 트랜잭션을 우선적으로 처리할지, 결정하기 위해 nonce 를 사용 
            - 우선 순위 결정을 할 때, 'nonce 와 가스비' 를 함께 사용해서, 우선순위를 결정 ⭐⭐ 
            - 가스비가 높을 수록, 트랜잭션 처리하는 순위가 높아짐 
            - nonce 는 '이중 지불 문제' 를 방지하기 위해 사용 ⭐⭐⭐⭐⭐⭐


    - value : 보내는 금액 
    
    - gasLimit : 최대 가스 사용량 
        - 가스리미트에 초과되는 양이 발생하면, reject 됨. 
        - 해당 트랜잭션이 사용할 수 있는, 최대치. 
    
    - gasprice : 보내는 사람이 지불하는 가스당의 가격, 수수료 
        - 가스 당 가격 

    - data : 스마트 컨트랙트, 스마트 계약의 주소, 어떤 계약을 실행시킬지! 에 대한 CA 의 주소와 함수를 호출하는 내용에 필요한 매개변수! 가 들어감
        : 즉, '스마트 계약의 주소' 와 '함수를 호출하는 내용에 필요한 매개변수' 


---

# 230919 테스트(TDD) 할 내용 ⭐⭐⭐⭐⭐ | 반드시 TDD 해보기 ⭐⭐⭐⭐⭐

1. 1개 지갑을 생성
    - 공개키와 개인키를 생성 -> 지갑이 하나 만들어짐. 현재 지갑 1개 생성된 상태


2. 지갑 주소로 블록을 생성(마이닝을 통해서)
3. 지갑은 블록 채굴 보상을 이 지갑이 받고 
    - 코인 베이스 트랜잭션을 블록에 추가 
    - 블록을 채굴할 때, '보상' 을 받게 되는데, 본인의 트랜잭션 내용을 만들게 됨 
        - 블록의 다음번 높이 값이 in 에 들어가야 하고 
        - 이 보상 받는 트랜잭션 내용에는 {주소 : 보상} 이 나와야 함. 
        - 블록 데이터에 추가한 뒤에, 
    - 블록 생성할 때, 연산을 통해, POW 로 블록 생성 권한을 얻을 때, 
    - 블록 생성을 하고 
    - txout에 있는 { 처음에 만든 지갑의 주소 : 보상 } 이게 -> UTXO 에 들어감
        - THEN, 지갑의 잔액을 UTXO 을 하면, 받은 보상이 나오게 됨. 


4. UTXO 채굴자 지갑의 계정과 블록 채굴 보상이 들어가 있는 상태 
    - 보상이 들어와 있는 상태 

5. 새로운 지갑을 하나 더 만들고 
    - 하나의 지갑 또 생성
    - 공개키, 개인키 설정
    - 처음에 지갑으로 트랜잭션을 생성
    - 첫번째 지갑에서 -> 두 번째 지갑으로 코인 전송

    - 개인키로 서명을 하고, 
    - 서명의 내용과 보내는 사람, 받는 사람, 전송금액, utxo 첫번째 지갑의 잔액을 조회해서 
    - 트랜잭션 풀에 담겨있고 (트랜잭션 대기 상태)

6. 채굴 보상을 받은 지갑에서, 새로운 지갑으로, 돈을 송금, 하는 트랜잭션을 발생 
7. 서명이 유효한지 검증을 거치고 -> 트랜잭션 풀에 담아 놓고 
8. 새로운 지갑이 블록을 마이닝해서, 채굴(코인 베이스 트랜잭션을 추가 = 채굴에 대한 보상을 받고) -> 트랜잭션 풀에 있는 트랜잭션을 처리 

    - 개인키와 서명을 가지고 발생 

    - 두 번째 지갑의 주소로 
        - 코인 베이스 트랜잭션, 트랜잭션 풀에 있는 대기상의 트랜잭션 내용

    - 두 번째 지갑 주소로 블록을 마이닝

    - 블록 추가 트랜잭션 풀에 있는 처리된 트랜잭션을 제거 {첫 번째 지갑 : 남은 금액} , {두 번째 지갑 : 받은 금액}

    - UTXO Pool 에 담김
    
    - 여기까지 하면, 객체가 추가 됨!


9. UTXO 에 처음 만든 지갑이 전송한 잔액이 새로운 지갑에 잔액으로 미사용 객체가 추가될 수 있게 
    - 첫 번째 지갑의 잔액 조회 
    - 두 번째 지갑의 잔액 조회
    - 잔액 조회 함수로 만들기 