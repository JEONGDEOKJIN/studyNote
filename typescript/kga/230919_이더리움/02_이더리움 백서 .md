

[이더리움 개념 2]


# 이더리움 

- 우리가 블록체인을 배우면서, 제일 좋은 법은? 
    - 만든 사람한테, 물어보는 것. 
    
    - 이더리움한테 물어보고 싶으면? 이더리움 만든 사람에게 물어보기
        - 비탈릭 부테린
        - 비탈릭 부테린이 적은 '이더리움 백서' 가 있음. 
            - https://ethereum.org/ko/whitepaper/ 

- 백서 내용
    - 이더리움은 '플랫폼' 임. 탈중앙화 어플리케이션 만들기 위한! 
    - 비트코인에는 수학적 내용이 많은데, 이더리움은 없음. 
    - 비트코인에 있는 내용을 '이름만 바꿔서' 쓰는 경우가 많음 
        - UTXO = state | utxo 기록되는 걸, 상태 전환으로 봄 

    - 시간 있으면 전체를 읽어보면 좋음 ⭐⭐

    - 중요한 내용 | 
        - 이더리움 부터 
            - 이더리움 계정
            - 메시지와 거래 
                - 트랜잭션 메시지 
            - 메시지 
                - 다만, p2p 할 때 썼던 메시지 아님. 
            - 이더리움 상태 전환 함수
                - 10이 빠지고, 10이 업데이트 된 상태 
            - 코드 실행 
                - EVM 으로 한다. 
        - 어플리케이션은 '아직은' 보지마 

    - 백서 내용 요약해서 수업 예정 👇👇👇


# 백서 내용 요약 BY 교수님 

## 이더리움은 차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플랫폼 
    - 이더리움 창시자 : 비탈릭 부테린 
    - 이더리움은 비트코인의 '보완' 을 좀 더 신경 씀
    - 비트코인이 많이 언급되는 걸로 보아, 교수님 개인적 생각으로, 사토시 나카모토를 옹호하는 경향이 있음. 
    - 내용을 보면, 비트코인과 크게 다른 점이 있는데,
        - 비트코인은 '결제' 에 포커스를 둬서 구현 했다면 
        - 이더리움은 '탈중앙화 어플리케이션' 을 제안 했다고 보면 됨
            - '플랫폼' 
            - 웹에서 플랫폼을 개발할 때, 편하게 개발하고 싶으니까. 
    
    - 여기서 중요한 내용은 
        - 1) '스마트 컨트랙트', '어플리케이션', 키워드가 중요함 ⭐⭐⭐
            - 이더리움은 '플랫폼' 에 포인트가 있음. 
            - 화폐 가치로 만들어진게 아님 
            - 이더리움을 쓰는 이유는 '무한 루프' 가 발생하기 때문에. 
            - 이더리움은 플랫폼 개발을 위해 사용하는데, 코인이니까, 화폐로 생각하는 경향이 많음. 

    - 백서의 내용을 보면 ❓❓❓❓❓❓❓😥😥😥😥😥 
        - 블록체인 기술을 사용한 대안적인 어플리케이션이 두 가지가 있는데, 
        - 사용자 정의 화폐와 금융 상품을 블록 체인 위로 표현하기 위한 컬러드 코인 
        - 물리적 대상의 소유권을 표현하는 스마트 자산
        - 도메인 이름과 같은 비동질적 자산을 기록하는 네임 코인
        - 이러한 어려운 내용을 계약의 규칙을 구현한 코드에 의해, 디지털 자산을 좀 더 관리하는게 편하도록, '스마트 컨트랙트', 를 만들고, 더 나아가, 블록체인을 기반으로한 '탈중앙화 자율조직 DAO' 등이 있고, 

        - 이더리움은 완벽한 '튜링 완전' 프로그래밍 언어가 심어진 블록체인,이다.  
            - '튜링 완전' 이란!? 
                - 앨런 튜링, 인물에 대해, 알아야 하고, 
                - 간단히 말해서, 계산 가능한 문제를, 해결할 수 있는 모든 기계의 공통된 능력

    - 이 프로그래밍 언어는 코딩된 규칙에 따라, '어떤 상태'를 다르게 변환 시키는 기능이 포함된 계약을 만드는데, 누가 만드냐? 
        - 유저들이 작성할 수 있게 해서, 설명한 시스템을 구현할 수 있게 한다. 

        - 우리가 아직 상상하지 못 한 어플리케이션을 쉽게 만들 수 있도록 도와주는 것
        - 그래서, '플랫폼 개발' 에 맞춰져 있음! 


## 비트코인 역사 
    - 과거에 비트코인과 비슷하게 암호화폐를 만들려고 시도하긴 함 
    - 중앙화되어 있던 데이터 의존 -> 조명을 받기 힘들었음. 
    - 탈중앙화의 개념을 제안하는 것을 계속 시도 -> 번번히 실패를 함
    - 사토시 나카모토, 가 합의 알고리즘(POW), 을 제안  
    - POW 의 사용으로, 탈중앙화를 실현시킴

    - 비탈릭 부테린은 
    - 작업 증명의 2가지 문제를 동시에 해결했다고 한다. 
    1. 아주 간단하면서, 효과가 좋은, 합의 알고리즘 제공 
    2. 누구나, 합의 프로세스에 참여할  수 있다. 

    이후에, 지분 증명(POS) 이라는 새로운 방식의 합의 알고리즘이 등장 

        - POW 는 각 노드가 가진 연산능력을 통해, NONCE 를 증가시켜서, 해쉬값 찾는 연산을 진행
        - POS 는 화폐의 보유량에 따라, 각 노드의 결정된 정도를 계산. 
            - 즉, 얼만큼 갖고 있는지에 따라서, 결정

        - 결국, 이더리움은 지분 증명을 선택함.

        - 지분증명으로 넘어간 이유 
            - 1) 서로 그룹을 모아서 -> 채굴하고 -> 보상을 나눠 -> 이게 발전되면, '중앙화의 위협' -> 채굴이 점점 힘들어짐 -> '누구나' 가 아닌게 됨.  
                즉, 누구나 합의 프로세스에 참여할 수 있는데, 컴퓨팅 파워가 많이 올라가다보니, 채굴에 급급한 마이너들이 그룹을 만들어서, 자기들 끼리 보상을 나누어 먹는 형태를 만들었음. 
                그 그룹이 거대해지면, 결국, 중앙화가 되는게 아니냐는 말이 나올 정도! 

            - 2) 환경 오염 

            - 이러한 이유로 POW에서 POS 로 변경됨


## 상태 변환 시스템으로서의 비트코인 

    - 비트코인의 트랜잭션 = 상태변환 시스템
        - 컴퓨터 공학에서 '상태' 를 많이 사용 

    - 이더리움 백서에서, 비트코인의 트랜잭션을, '상태변환 시스템' 이라고 말하고 있음. 

    - 비트코인의 트랜잭션은 UTXO 인데, 이더리움은 트랜잭션 내용을 상태처리, 라고 하고 있음. 

    - 우리가 배운 내용에서 쉽게 보자면, 추상적으로, '리액트' 의 '상태' 라고 봐도 무방하긴 함. 


    - '상태' 에 대해서 간단히 설명하면, 
        - 쇼핑몰을 만들었는데, '물건을 구매' 할 때의 '상태' 가 필요함 
            - EX) '상품의 현재 상태' 를 나타낼 테이블을 만들었음. 
            - 상품 테이블에 '주문' 이라는 상태가 있음 
                - '주문' 의 세부 상태 
                    - '주문 접수' 상태 -> '결제 확인' '상태 상품 준비' 상태 -> '상품 발송' 상태 -> '배송 완료' 상태 -> '상품 수령' 상태 ex) 리뷰 써주세요~ 
                - 이러한 field(column) 이 필요 ex) order 테이블에서 > state field(column) 

    - 이러한 개념이 등장 
        - 'UTXO -> Transaction' -> UTXO
        - 우리가 UTXO 를 통해, 계정의 Account 들의 balance 를 구했고 -> 새로운 UTXO 를 만들어주는 것을 '상태' 에 비유했음. ⭐⭐ | 그래서, 상태가 바뀐다! 라고 했음. 
            - account 라는 개념이 '이더리움' 에서 나옴 (원래는 address 였음.) (account 을 address 로 말하는 사람들이 있음 ⭐⭐) 


## 스크립팅 
    - 비트코인이 정말 낮은 수준의 스마트 컨트랙트는 존재함. 그런데, 이 내용이 힘듦

    - 비탈릭 부테린은 서명에 관련된 로직을, 스마트 컨트랙트 라는 시점으로, 바라보고 있음. 

    - 비트코인의 UTXO 공개키 만으로, 해당 계정의 잔액을 조회할 수 있는데, 단순히, 스택의 기반으로 프로그래밍 언어로 표현되어 있는데, ⭐⭐

        토이 비트코인을 만들면서, 한명 한명의 서명을 만들어 트랜잭션을 생서 처리 했는데, 

        비트코인에서 2,3개의 개인키를 가지고, 서명을 만들어서, 검증할 수 있도록, 간단한 스크립팅, 을 작성할 수 있다. (이걸 실제로 사용한 플랫폼이 없음. 어렵기 때문에)

    - 이더리움은 이 내용을 '스마트 컨트랙트' 개념으로 보고 있음. ⭐⭐⭐⭐⭐
        - 문제점 
            - 튜링 불완전성 
            - 가치가 없다. 
            - 다양한 상태를 표현할 수 없다. 
            - 블록체인의 해독할 방법이 없다. 


## 이더리움의 목적
    - 이더리움의 목적은 '분산 어플리케이션 제작' 을 위한 대체 프로토콜 ⭐⭐⭐⭐⭐(이더리움을 짧게 문장으로 나타내면) 
        - 그래서, 누구나, 쉽게, 분산 어플리케이션 제작을 쉽게 할 수 있음. 

    - 비트코인을 가지고, 보험 상품을 못 만들어. 왜냐면, 이자를 구현하기 힘드니까. 이렇게 생각하는 이유는 
        1. bitcoin 을 가지고, 예금, 보험, 금융 상품에 대한 것을 구현할 수 없음. (이자 구현 X)
        
        2. 사이트 및 게임에 적용하기 힘든 부분들이 많음. 
            - 상품 및 게임 아이템 매칭 X 
            - 비트코인은 트래잭션 처리도 느림 
            - 비트코인은 '결제' 중심 | 이더리움은 '플랫폼' 중심 

    - 결제
        - 비트코인은 '결제' 에만 포커싱이 있음. 
        - '이자' 에 대한 부분은 따로 구현해서, 처리 해야 함. 

        - 이더리움은 이 부분을 보완해서, 이더리움 이라는 플랫폼을 만든 것. 

        - 적은 시간으로 탈중앙화를 사용해서, 데이터를 '저장' 하는 사이트, '게임' 을 만들 수 있게 되었음. ⭐⭐⭐⭐⭐⭐⭐⭐

    - Dapp
        - 우리는 이런 것들을 DAPP 이라고 부른다. | 즉, 이더리움을 통해 Dapp 개발 | 이더리움을 활용한 게임 및 어플리케이션 ⭐⭐⭐⭐⭐ |

        - 탈중앙화랑, 통신할 수 있는 프로토콜을, 유저가 쉽게 구현할 수 있도록 도와준다. 

        - 탈중앙화에, 데이터를, 저장할 수 있다 == 스마트 컨트랙트 
            - 이게 가능한 이유는, 이더리움은 '튜링 완전' 을 내장하고 있어서 ⭐⭐
            - 이 말은 js 처럼, 컴퓨터 능력으로 코드를 실행할 수 있다. 
            - 그로 인해, 비트코인의 UTXO 형식적인 데이터가 아닌, 상태를 즉 변화를 만들어서, 
            다양한 데이터를 저장하고, 사용할 수 있도록, 트랜잭션의 구조를 완전히 바꾼 것

    - account 에는 2가지 종류가 있음. 
        - CA, EOA 를 자세히 보자 


## 이더리움 ACCOUNT 
    - 이더리움에는 '상태(state)' 는 'account' 라고 하는 객체로 구성되어 있다. 

    - 토이 비트코인에서 만들었던, '지갑' 은 
        - 개인키를 가지고 -> 공개키를 만들고 -> 12바이트를 잘라서, 만들었던게 ('주소' 이자 ) 'account' ⭐⭐

    - 이더리움에서의 account

        ``` js
        interface Account {
            // 이 계정이 트랜잭션 발생시킨 횟수 
            nonce : number; 
                // 트랜잭션의 횟수, counter 변수랑 비슷 (이중지불 방지 용도)
                // 트랜잭션 발생시켰을 때 nonce 가 2 임 -> 해당 지갑에서, 다음 트랜잭션을 하면, nonce 는 3이 되어야 함 

            // 이더리움 잔액
            balance : string;   // ✅ '이더' 
            
            // account 상태 저장 공간 (스마트 컨트랙트 안 해서, 여기는 아직 모름)
            storageRoot : string;
                // 초기에는 비어있음. 

            // 스마트 컨트랙트 계약의 코드 가 들어감. (스마트 컨트랙트 안 해서, 여기는 아직 모름)
            codeHash : string;
        }
        ```


    - '이더' 라는 이더리움 플랫폼의 화폐 단위가 있고 

    - '이더' 화폐를 만든 이유? 
        - 트랜잭션 발생 시킬 때, 수수료를 지불하는데
        - 이더리움 네트워크는 '이더' 라는 친구가 없으면, '코드' 를 실행할 수 없게 하기 위해서, 
        - 데이터도 저장할 수 없다. 
            - 즉, 이더 같은 게 없으면, 무한대로 사용하게 될 것. 
        - 즉, '이더' 가 있어야, 상태값 같은걸 변경할 수 있음. 


## Account 의 2가지 개념 
    
    - account 를 address 라고 부르는 사람들이 있음. 

    - 공통점 
        위에 있는 account 코드를 공유함 

    - EOA, CA 의 차이 
        - EOA 
            - 프라이빗 키에 의해 통제되는 외부 소유 ACCOUNT
            - EOA 사용하는 지갑
            - 쉽게 말해, 토이로 만들었던, 비트코인의 지갑(ACCOUNT) 의 개념 ⭐⭐
            - EOA 가 EOA 에게 돈을 보내고 받을 수 있음. 
            - 다른 ACCOUNT 에 이더를 주고 받을 수 있음. 
            - 개인키가 존재. 개인키를 가지고 서명을 해서, 트랜잭션을 생성. 
            - 트랜잭션을 이더리움 백서에서는 '메시지' 라고 함 ⭐⭐


        ``` js
        // EOA account
        interface Account {
            // 이 계정이 트랜잭션 발생시킨 횟수 (카운터)
            nonce : number; 

            // 이더리움 잔액
            balance : string;   // '이더' 
            
            // account 상태 저장 공간 
            storageRoot : string;   // EOA account는 사용 ❎

            // 스마트 컨트랙트 계약의 코드 
            codeHash : string;  // EOA account는 사용 ❎
        }
        ```
        - EOA 에서 개인키는? 공개키는? 
            - 개인키는 갖고 있음. 
            - 메타마스크에 계정을 생성했다면, ⭐확장 프로그램 안에, 안전하게 보관되어 있음. ⭐
            - 개인키는 본인이 갖고 있음. 
            
            - 객체 생성할 때, 만들 때, 객체가 나옴 
                - 이렇게 해서 공개키가 나옴 👇👇
            new Account === 0xsdkfjlsakdfjslkaf {

            }

        - CA
            - CA 계정은 Account 객체 구조에 있는 ⭐모든 속성을 사용한다. 
            - 대신, '개인키가 없음' ⭐
                - 개인키 없으니까 -> 메시지 못 보냄 ⭐
                - 있는 이유는, 컨트롤 되기 위해서 존재함 

            - 나중에, 스마트 컨트랙트 코드를 작성할 것 임. 
                - 솔리디티 언어를 사용해서, 컨트랙트 코드를 작성하는데, 

                ```
                pragma solidity ^0.8.0

                // 이게 하나의 컨트랙트 
                contract testContract {
                    
                    unit256 value;  // 상태 변수 선언
                        // unit256 은 변수 

                    function setValue(unit256 newValue) public {
                        value = newValue;   // 상태변수를 변경
                    }

                    function getValue() public view returns (unit256) {
                        // 상태변수 조회. 가스비 수수료를 내지 않음. 
                        // 한정된 자원을 사용하면 -> 가스비를 냄 ⭐
                        return value;
                    }
                }
                ```

                - 이때, codehash 들은 코드를 컴파일해서, 결과를 저장한다.
                - storageRoot 에는 value 상태 변수를 키와 값의 형태로 데이터 저장을 한다. 
                - CA 는 메시지를 발생시킬 수 없음. 왜냐면, 개인키가 없기 때문이다. 
                - 그러면, CA 는 어떻게 사용하는 것? 
                    - Message(메시지)라는 것을 받으면, CA 가 자신의 코드를 활성화 시키고, 
                        1) 메시지가 어떤 값인지를 보고 읽거나, 상태 변수 의 내용을 변경하게 된다.⭐
                        2) 혹은 Message 를 보낼 수 있게 된다. ⭐


## 메시지와 트랜잭션 
    - 이더리움에서 서명이 있는 영수증 -> 트랜잭션, ⭐ 
    - 이더리움에서 서명이 없는 영수증 -> 메시지. | p2p 에 적힌 socket 메시지가 아님 ⭐

    - EOA 계정 -> 서명이 있음.
    - EOA -> transaction 
    - CA -> message

    
// (트랜잭션의 객체 내용을 인터페이스로 작성)
    
``` javascript

interface Message {
    from : string   // 메시지를 보내는 account or 컨트랙트의 주소
    to : string     // 메시지를 받는 account or 컨트랙드의 주소 
    gas : number    // 메시지를 처리하기 위해 사용할 가스의 양
    gasPrice : number   // 가스당의 가격 | 리터당 얼마에요? | 가스당 얼마에요? 
    value : number  // 메시지와 함께 전송할 이더의 량 
    data : string   // 메시지 데이터 | 스마트 컨트랙트 코드 CA 와 매개변수에 대한 내용이 들어감. 
    nonce : number  // 트랜잭션 발생시킨 계정의 nonce 값. 메시지를 전송한 account 의 nonce 값
                    // 비트코인 nonce 랑 완전 다름. 트랜잭션 발생을 카운팅 한 것 

}

interface Transaction extends Message {
     
    v : number;     // v 는 '서명' 에 대한 내용 | 서명 v 값!
    r : number;     // 서명 r 값
    s : number;     // 서명 s 값

}

```

- 가스는 이후에 우리가 좀 더 진행을 하면서, 좀 더 추가로, 알아볼 것임. 
- 가스는 예를 들어, 
    - 차를 끌고, 주유소에 가서, 리터당 얼마다~ 라는 걸 본다. 
    - 1L 2000원 이면 -> 총 얼마 넣었는지를 계산해서 -> 금액 
    - 알기로는 byte 당 5gas 로 측정 된다. 